From 8f3f86200cfc9a0cc5f2e33d1954206b7016e9e4 Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Mon, 7 Jun 2021 10:13:24 -0400
Subject: [PATCH 01/28] changing the restore topology routine to load the
 switches, interfaces and links on Kytos startup

---
 main.py | 199 ++++++++++++++++++++++----------------------------------
 1 file changed, 79 insertions(+), 120 deletions(-)

diff --git a/main.py b/main.py
index 70c7f28..85f0c3d 100644
--- a/main.py
+++ b/main.py
@@ -3,6 +3,7 @@
 Manage the network topology
 """
 import time
+from datetime import datetime, timezone
 
 from flask import jsonify, request
 from werkzeug.exceptions import BadRequest, UnsupportedMediaType
@@ -19,8 +20,6 @@
 from napps.kytos.topology.storehouse import StoreHouse
 
 DEFAULT_LINK_UP_TIMER = 10
-DEFAULT_INTERFACE_RESTORE_TIMER = 2
-RESTORE_INTERFACE_ATTEMPTS = 20
 
 
 class Main(KytosNApp):  # pylint: disable=too-many-public-methods
@@ -33,14 +32,8 @@ def setup(self):
         """Initialize the NApp's links list."""
         self.links = {}
         self.store_items = {}
-        self.switches_state = {}
-        self.interfaces_state = {}
-        self.links_state = {}
-        self._verified_links = []
         self.link_up_timer = getattr(settings, 'LINK_UP_TIMER',
                                      DEFAULT_LINK_UP_TIMER)
-        self.interface_restore = getattr(settings, 'INTERFACE_RESTORE_TIMER',
-                                         DEFAULT_INTERFACE_RESTORE_TIMER)
 
         self.verify_storehouse('switches')
         self.verify_storehouse('interfaces')
@@ -121,94 +114,67 @@ def _get_link_from_interface(self, interface):
                 return link
         return None
 
-    def _restore_link(self, link_id):
-        """Restore link's administrative state from storehouse."""
-        try:
-            state = self.links_state[link_id]
-        except KeyError:
-            error = (f'The link {link_id} has no stored '
-                     'administrative state to be restored.')
-            raise RestoreError(error)
-
-        try:
-            link = self.links[link_id]
-            if state['enabled']:
-                link.enable()
-            else:
-                link.disable()
-        except KeyError:
-            error = ('Error restoring link status.'
-                     f'The link {link_id} does not exist.')
-            raise RestoreError(error)
-        log.info(f'The state of link {link.id} has been restored.')
-        self.notify_topology_update()
-        self.update_instance_metadata(link)
-        self.notify_link_status_change(link)
-
-    def _restore_switch(self, switch_id):
-        """Restore switch's administrative state from storehouse."""
-        try:
-            state = self.switches_state[switch_id]
-        except KeyError:
-            error = (f'The switch {switch_id} has no stored'
-                     ' administrative state to be restored.')
-            raise RestoreError(error)
-
-        try:
-            switch = self.controller.switches[switch_id]
-        except KeyError:
-            # Maybe we should remove the switch from switches_state here
-            error = ('Error while restoring switches status. The '
-                     f'switch {switch_id} does not exist.')
-            raise RestoreError(error)
-
-        if state:
+    def _load_switch(self, switch_id, switch_att):
+        log.info(f'Loading switch from storehouse dpid={switch_id}')
+        switch = Switch(dpid=switch_id)
+        self.controller.add_new_switch(switch)
+        # workaround so switch.is_active() returns False
+        switch.lastseen = datetime(1, 1, 1, 0, 0, 0, 0, timezone.utc)
+        if switch_att['enabled']:
             switch.enable()
-            self.notify_switch_enabled(switch_id)
         else:
             switch.disable()
-            self.notify_switch_disabled(switch_id)
-
-        log.debug('Waiting to restore administrative state of switch '
-                  f'{switch_id} interfaces.')
-        i = 0
-        # wait to restore interfaces
-        while not switch.interfaces and i < RESTORE_INTERFACE_ATTEMPTS:
-            time.sleep(self.interface_restore)
-            i += 1
-        if not switch.interfaces:
-            error = ('Error restoring administrative state of switch '
-                     f'{switch_id} interfaces.')
-            raise RestoreError(error)
-
-        # restore interfaces
-        for interface_id in switch.interfaces:
-            iface_id = ":".join([switch_id, str(interface_id)])
-            # restore only the administrative state of saved interfaces
-            if iface_id not in self.interfaces_state:
-                error = ("The stored topology is different from the current "
-                         f"topology. The interface {iface_id} hasn't been "
-                         "stored.")
-                log.info(error)
-                continue
-            state = self.interfaces_state[iface_id]
-            iface_number = int(interface_id)
-            iface_status, lldp_status = state
-            try:
-                interface = switch.interfaces[iface_number]
-            except KeyError:
-                log.error('Error restoring interface status: '
-                          '%s does not exist.', iface_id)
-                continue
-
-            if iface_status:
+        switch.description['manufacturer'] = switch_att.get('manufacturer', '')
+        switch.description['hardware'] = switch_att.get('hardware', '')
+        switch.description['software'] = switch_att.get('software')
+        switch.description['serial'] = switch_att.get('serial', '')
+        switch.description['data_path'] = switch_att.get('data_path', '')
+        self.update_instance_metadata(switch)
+        for iface_id, iface_att in switch_att.get('interfaces', {}).items():
+            log.info(f'Loading interface iface_id={iface_id}')
+            interface = Interface(name=iface_att['name'],
+                                  port_number=iface_att['port_number'],
+                                  address=iface_att.get('mac', None),
+                                  speed=iface_att.get('speed', None),
+                                  switch=switch)
+            interface.deactivate()
+            if iface_att['enabled']:
                 interface.enable()
             else:
                 interface.disable()
-            interface.lldp = lldp_status
+            interface.lldp = iface_att['lldp']
+            switch.update_interface(interface)
             self.update_instance_metadata(interface)
 
-        log.info(f'The state of switch {switch_id} has been restored.')
+    def _load_link(self, link_att):
+        dpid_a = link_att['endpoint_a']['switch']
+        dpid_b = link_att['endpoint_b']['switch']
+        port_a = link_att['endpoint_a']['port_number']
+        port_b = link_att['endpoint_b']['port_number']
+        link_str = f'{dpid_a}:{port_a}-{dpid_b}:{port_b}'
+        log.info(f'Loading link from storehouse {link_str}')
+
+        try:
+            switch_a = self.controller.switches[dpid_a]
+            switch_b = self.controller.switches[dpid_b]
+            interface_a = switch_a.interfaces[port_a]
+            interface_b = switch_b.interfaces[port_b]
+        except Exception as err:
+            error = f'Fail to load endpoints for link {link_str}: {err}'
+            raise RestoreError(error)
+
+        link = self._get_link_or_create(interface_a, interface_b)
+
+        if link_att['enabled']:
+            link.enable()
+        else:
+            link.disable()
+
+        interface_a.update_link(link)
+        interface_b.update_link(link)
+        interface_a.nni = True
+        interface_b.nni = True
+        self.update_instance_metadata(link)
 
     # pylint: disable=attribute-defined-outside-init
     def _load_network_status(self):
@@ -216,26 +182,33 @@ def _load_network_status(self):
         try:
             status = self.storehouse.get_data()
         except FileNotFoundError as error:
-            log.info(error)
+            log.error(f'Fail to load network status from storehouse: {error}')
             return
-        if status:
-            switches = status['network_status']['switches']
-            self.links_state = status['network_status']['links']
-
-            for switch_id, switch_att in switches.items():
-                # get switches status
-                self.switches_state[switch_id] = switch_att['enabled']
-                iface = switch_att['interfaces']
-                # get interface status
-                for iface_id, iface_att in iface.items():
-                    enabled_value = iface_att['enabled']
-                    lldp_value = iface_att['lldp']
-                    self.interfaces_state[iface_id] = (enabled_value,
-                                                       lldp_value)
 
-        else:
-            error = 'There is no status saved to restore.'
-            log.info(error)
+        if not status:
+            log.info('There is no status saved to restore.')
+            return
+
+        switches = status['network_status']['switches']
+        links = status['network_status']['links']
+
+        log.debug("_load_network_status switches=%s" % switches)
+        for switch_id, switch_att in switches.items():
+            if switch_id not in self.controller.switches:
+                try:
+                    self._load_switch(switch_id, switch_att)
+                # pylint: disable=broad-except
+                except Exception as err:
+                    log.error(f'Error loading switch: {err}')
+
+        log.debug("_load_network_status links=%s" % links)
+        for link_id, link_att in links.items():
+            if link_id not in self.links:
+                try:
+                    self._load_link(link_att)
+                # pylint: disable=broad-except
+                except Exception as err:
+                    log.error(f'Error loading link: {err}')
 
     @rest('v3/')
     def get_topology(self):
@@ -245,18 +218,6 @@ def get_topology(self):
         """
         return jsonify(self._get_topology_dict())
 
-    def restore_network_status(self, obj):
-        """Restore the network administrative status saved in storehouse."""
-        try:
-            if isinstance(obj, Switch):
-                self._restore_switch(obj.id)
-            elif isinstance(obj, Link):
-                if obj.id not in self._verified_links:
-                    self._verified_links.append(obj.id)
-                    self._restore_link(obj.id)
-        except RestoreError as exc:
-            log.debug(exc)
-
     # Switch related methods
     @rest('v3/switches')
     def get_switches(self):
@@ -535,7 +496,6 @@ def handle_new_switch(self, event):
         log.debug('Switch %s added to the Topology.', switch.id)
         self.notify_topology_update()
         self.update_instance_metadata(switch)
-        self.restore_network_status(switch)
         if switch.is_enabled():
             self.notify_switch_enabled(switch.id)
 
@@ -679,7 +639,6 @@ def add_links(self, event):
         interface_b.nni = True
 
         self.notify_topology_update()
-        self.restore_network_status(link)
 
     # def add_host(self, event):
     #    """Update the topology with a new Host."""

From 5dfdc0bb2d7c46cc53bb43ababc37d4fa2e446c6 Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Tue, 8 Jun 2021 22:47:50 -0400
Subject: [PATCH 02/28] cleaning up settings and adjusting unit tests

---
 settings.py             |   2 -
 tests/unit/test_main.py | 398 ++++++++++++++++++++++++++++++----------
 2 files changed, 305 insertions(+), 95 deletions(-)

diff --git a/settings.py b/settings.py
index f756511..290b26d 100644
--- a/settings.py
+++ b/settings.py
@@ -7,5 +7,3 @@
 LINK_UP_TIMER = 10
 # Time (in seconds) to wait retrieve box from storehouse
 BOX_RESTORE_TIMER = 0.1
-# Time (in seconds) to wait before restore interfaces
-INTERFACE_RESTORE_TIMER = 2
diff --git a/tests/unit/test_main.py b/tests/unit/test_main.py
index 7d98502..3bd7704 100644
--- a/tests/unit/test_main.py
+++ b/tests/unit/test_main.py
@@ -190,138 +190,350 @@ def test_get_topology(self):
     @patch('napps.kytos.topology.main.StoreHouse.get_data')
     def test_load_network_status(self, mock_storehouse_get_data):
         """Test _load_network_status."""
+        link_id = \
+            'cf0f4071be426b3f745027f5d22bc61f8312ae86293c9b28e7e66015607a9260'
+        dpid_a = '00:00:00:00:00:00:00:01'
+        dpid_b = '00:00:00:00:00:00:00:02'
         status = {
             'network_status': {
                 'id': 'network_status',
                 'links': {
-                    '4d42dc08522': {
+                    link_id: {
                         'enabled': True,
                         'endpoint_a': {
-                            'switch': '00:00:00:00:00:00:00:01',
-                            'id': '00:00:00:00:00:00:00:00:1'
+                            'switch': dpid_a,
+                            'port_number': 2
                         },
                         'endpoint_b': {
-                            'switch': '00:00:00:00:00:00:00:01',
-                            'id': '00:00:00:00:00:00:00:00:2'
+                            'switch': dpid_b,
+                            'port_number': 2
                         }
                     }
                 },
                 'switches': {
-                    '00:00:00:00:00:00:00:01': {
-                        'dpid': '00:00:00:00:00:00:00:01',
+                    dpid_a: {
+                        'dpid': dpid_a,
                         'enabled': True,
-                        'id': '00:00:00:00:00:00:00:01',
+                        'id': dpid_a,
                         'interfaces': {
-                            '00:00:00:00:00:00:00:01:1': {
+                            f'{dpid_a}:2': {
                                 'enabled': True,
                                 'lldp': True,
-                                'id': '00:00:00:00:00:00:00:00:1',
+                                'port_number': 2,
+                                'name': 's1-eth2'
+                            }
+                        }
+                    },
+                    dpid_b: {
+                        'dpid': dpid_b,
+                        'enabled': True,
+                        'id': dpid_b,
+                        'interfaces': {
+                            f'{dpid_b}:2': {
+                                'enabled': True,
+                                'lldp': True,
+                                'port_number': 2,
+                                'name': 's2-eth2'
                             }
                         }
                     }
                 }
             }
         }
-        switches_expected = {'00:00:00:00:00:00:00:01': True}
-        interfaces_expected = {'00:00:00:00:00:00:00:01:1': (True, True)}
+        switches_expected = [dpid_a, dpid_b]
+        interfaces_expected = [f'{dpid_a}:2', f'{dpid_b}:2']
+        links_expected = [link_id]
         mock_storehouse_get_data.return_value = status
         self.napp._load_network_status()
-        self.assertDictEqual(switches_expected, self.napp.switches_state)
-        self.assertDictEqual(interfaces_expected, self.napp.interfaces_state)
-        self.assertDictEqual(status['network_status']['links'],
-                             self.napp.links_state)
-
-    # pylint: disable=too-many-locals
-    def test_restore_network_status(self):
-        """Test restore_network_status."""
-        dpid = '00:00:00:00:00:00:00:01'
-        mock_switch = get_switch_mock(dpid)
-        mock_switch.id = dpid
-        mock_interface = get_interface_mock('s1-eth1', 1, mock_switch)
-        mock_switch.interfaces = {1: mock_interface}
-        self.napp.controller.switches = {dpid: mock_switch}
-        self.napp.switches_state = {dpid: True}
-        self.napp.interfaces_state = {'00:00:00:00:00:00:00:01:1': (True,
-                                                                    True)}
+        self.assertListEqual(switches_expected,
+                             list(self.napp.controller.switches.keys()))
+        interfaces = []
+        for switch in self.napp.controller.switches.values():
+            for iface in switch.interfaces.values():
+                interfaces.append(iface.id)
+        self.assertListEqual(interfaces_expected, interfaces)
+        self.assertListEqual(links_expected, list(self.napp.links.keys()))
 
-        # enable
-        self.napp.restore_network_status(mock_switch)
-        self.assertEqual(mock_switch.enable.call_count, 1)
-        self.assertEqual(mock_interface.enable.call_count, 1)
-        self.assertEqual(mock_interface.lldp, True)
-
-        # disable
-        self.napp.switches_state = {dpid: False}
-        self.napp.interfaces_state = {'00:00:00:00:00:00:00:01:1': (False,
-                                                                    False)}
-        self.napp.restore_network_status(mock_switch)
-        self.assertEqual(mock_switch.disable.call_count, 1)
-        self.assertEqual(mock_interface.disable.call_count, 1)
-        self.assertEqual(mock_interface.lldp, False)
+    @patch('napps.kytos.topology.main.StoreHouse.get_data')
+    @patch('napps.kytos.topology.main.log')
+    def test_load_network_status_fail(self, *args):
+        """Test _load_network_status failure."""
+        (mock_log, mock_storehouse_get_data) = args
+        mock_log.error.return_value = True
+        mock_storehouse_get_data.side_effect = FileNotFoundError('xpto')
+        self.napp._load_network_status()
+        error = 'Fail to load network status from storehouse: xpto'
+        mock_log.error.assert_called_with(error)
 
-    def test_restore_links(self):
-        """Test restore_link."""
-        dpid = '00:00:00:00:00:00:00:01'
-        dpid_b = '00:00:00:00:00:00:00:02'
+    @patch('napps.kytos.topology.main.StoreHouse.get_data')
+    @patch('napps.kytos.topology.main.log')
+    def test_load_network_status_does_nothing(self, *args):
+        """Test _load_network_status doing nothing."""
+        (mock_log, mock_storehouse_get_data) = args
+        mock_log.info.return_value = True
+        mock_storehouse_get_data.return_value = {}
+        self.napp._load_network_status()
+        error = 'There is no status saved to restore.'
+        mock_log.info.assert_called_with(error)
+
+    @patch('napps.kytos.topology.main.StoreHouse.get_data')
+    @patch('napps.kytos.topology.main.Main._load_switch')
+    @patch('napps.kytos.topology.main.log')
+    def test_load_network_status_fail_switch(self, *args):
+        """Test _load_network_status failure in switch."""
+        (mock_log, mock_load_switch, mock_get_data) = args
+        status = {
+            'network_status': {
+                'id': 'network_status',
+                'links': {},
+                'switches': {
+                    '1': {}
+                }
+            }
+        }
+        mock_log.error.return_value = True
+        mock_get_data.return_value = status
+        mock_load_switch.side_effect = Exception('xpto')
+        self.napp._load_network_status()
+        error = 'Error loading switch: xpto'
+        mock_log.error.assert_called_with(error)
+
+    @patch('napps.kytos.topology.main.StoreHouse.get_data')
+    @patch('napps.kytos.topology.main.Main._load_link')
+    @patch('napps.kytos.topology.main.log')
+    def test_load_network_status_fail_link(self, *args):
+        """Test _load_network_status failure in link."""
+        (mock_log, mock_load_link, mock_get_data) = args
+        status = {
+            'network_status': {
+                'id': 'network_status',
+                'switches': {},
+                'links': {
+                    '1': {}
+                }
+            }
+        }
+        mock_log.error.return_value = True
+        mock_get_data.return_value = status
+        mock_load_link.side_effect = Exception('xpto')
+        self.napp._load_network_status()
+        error = 'Error loading link: xpto'
+        mock_log.error.assert_called_with(error)
+
+    def test_load_switch(self):
+        """Test _load_switch."""
+        dpid_a = "00:00:00:00:00:00:00:01"
+        dpid_x = "00:00:00:00:00:00:00:XX"
+        iface_a = f'{dpid_a}:1'
+        switch_attrs = {
+            'dpid': dpid_a,
+            'enabled': True,
+            'id': dpid_a,
+            'interfaces': {
+                iface_a: {
+                    'enabled': True,
+                    'lldp': True,
+                    'id': iface_a,
+                    'switch': dpid_a,
+                    'name': 's2-eth1',
+                    'port_number': 1
+                }
+            }
+        }
+        self.napp._load_switch(dpid_a, switch_attrs)
+
+        self.assertEqual(len(self.napp.controller.switches), 1)
+        self.assertIn(dpid_a, self.napp.controller.switches)
+        self.assertNotIn(dpid_x, self.napp.controller.switches)
+        switch = self.napp.controller.switches[dpid_a]
+
+        self.assertEqual(switch.id, dpid_a)
+        self.assertEqual(switch.dpid, dpid_a)
+        self.assertTrue(switch.is_enabled())
+        self.assertFalse(switch.is_active())
+
+        self.assertEqual(len(switch.interfaces), 1)
+        self.assertIn(1, switch.interfaces)
+        self.assertNotIn(2, switch.interfaces)
+        interface = switch.interfaces[1]
+        self.assertEqual(interface.id, iface_a)
+        self.assertEqual(interface.switch.id, dpid_a)
+        self.assertEqual(interface.port_number, 1)
+        self.assertTrue(interface.is_enabled())
+        self.assertFalse(interface.is_active())
+        self.assertTrue(interface.lldp)
+        self.assertTrue(interface.uni)
+        self.assertFalse(interface.nni)
+
+    def test_load_switch_attrs(self):
+        """Test _load_switch."""
+        dpid_b = "00:00:00:00:00:00:00:02"
+        iface_b = f'{dpid_b}:1'
+        switch_attrs = {
+            "active": True,
+            "connection": "127.0.0.1:43230",
+            "data_path": "XX Human readable desc of dp",
+            "dpid": "00:00:00:00:00:00:00:02",
+            "enabled": False,
+            "hardware": "Open vSwitch",
+            "id": "00:00:00:00:00:00:00:02",
+            "interfaces": {
+                "00:00:00:00:00:00:00:02:1": {
+                    "active": True,
+                    "enabled": False,
+                    "id": "00:00:00:00:00:00:00:02:1",
+                    "link": "",
+                    "lldp": False,
+                    "mac": "de:58:c3:30:b7:b7",
+                    "metadata": {},
+                    "name": "s2-eth1",
+                    "nni": False,
+                    "port_number": 1,
+                    "speed": 1250000000,
+                    "switch": "00:00:00:00:00:00:00:02",
+                    "type": "interface",
+                    "uni": True
+                },
+            },
+            "manufacturer": "Nicira, Inc.",
+            "metadata": {},
+            "name": "00:00:00:00:00:00:00:04",
+            "ofp_version": "0x04",
+            "serial": "XX serial number",
+            "software": "2.10.7",
+            "type": "switch"
+        }
+
+        self.napp._load_switch(dpid_b, switch_attrs)
+
+        self.assertEqual(len(self.napp.controller.switches), 1)
+        self.assertIn(dpid_b, self.napp.controller.switches)
+
+        switch = self.napp.controller.switches[dpid_b]
+        self.assertEqual(switch.id, dpid_b)
+        self.assertEqual(switch.dpid, dpid_b)
+        self.assertFalse(switch.is_enabled())
+        self.assertFalse(switch.is_active())
+        self.assertEqual(switch.description['manufacturer'], 'Nicira, Inc.')
+        self.assertEqual(switch.description['hardware'], 'Open vSwitch')
+        self.assertEqual(switch.description['software'], '2.10.7')
+        self.assertEqual(switch.description['serial'], 'XX serial number')
+        self.assertEqual(switch.description['data_path'],
+                         'XX Human readable desc of dp')
+
+        self.assertEqual(len(switch.interfaces), 1)
+        self.assertIn(1, switch.interfaces)
+        self.assertNotIn(2, switch.interfaces)
+
+        interface = switch.interfaces[1]
+        self.assertEqual(interface.id, iface_b)
+        self.assertEqual(interface.switch.id, dpid_b)
+        self.assertEqual(interface.port_number, 1)
+        self.assertFalse(interface.is_enabled())
+        self.assertFalse(interface.is_active())
+        self.assertFalse(interface.lldp)
+        self.assertTrue(interface.uni)
+        self.assertFalse(interface.nni)
+
+    def test_load_link(self):
+        """Test _load_link."""
+        dpid_a = "00:00:00:00:00:00:00:01"
+        dpid_b = "00:00:00:00:00:00:00:02"
+        mock_switch_a = get_switch_mock(dpid_a, 0x04)
+        mock_switch_b = get_switch_mock(dpid_b, 0x04)
+        mock_interface_a = get_interface_mock('s1-eth1', 1, mock_switch_a)
+        mock_interface_a.id = dpid_a + ':1'
+        mock_interface_b = get_interface_mock('s2-eth1', 1, mock_switch_b)
+        mock_interface_b.id = dpid_b + ':1'
+        mock_switch_a.interfaces = {1: mock_interface_a}
+        mock_switch_b.interfaces = {1: mock_interface_b}
+        self.napp.controller.switches[dpid_a] = mock_switch_a
+        self.napp.controller.switches[dpid_b] = mock_switch_b
+        link_attrs = {
+            'enabled': True,
+            'endpoint_a': {
+                'switch': dpid_a,
+                'port_number': 1
+            },
+            'endpoint_b': {
+                'switch': dpid_b,
+                'port_number': 1
+            }
+        }
+
+        self.napp._load_link(link_attrs)
+
+        self.assertEqual(len(self.napp.links), 1)
+        link = list(self.napp.links.values())[0]
+
+        self.assertEqual(link.endpoint_a.id, mock_interface_a.id)
+        self.assertEqual(link.endpoint_b.id, mock_interface_b.id)
+        self.assertTrue(mock_interface_a.nni)
+        self.assertTrue(mock_interface_b.nni)
+        self.assertEqual(mock_interface_a.update_link.call_count, 1)
+        self.assertEqual(mock_interface_b.update_link.call_count, 1)
+
+        # test enable/disable
         link_id = '4d42dc08522'
-        mock_switch_a = get_switch_mock(dpid)
-        mock_switch_b = get_switch_mock(dpid_b)
-        mock_interface_a_1 = get_interface_mock('s1-eth1', 1, mock_switch_a)
-        mock_interface_b_1 = get_interface_mock('s2-eth1', 1, mock_switch_b)
-        mock_link = get_link_mock(mock_interface_a_1, mock_interface_b_1)
+        mock_interface_a = get_interface_mock('s1-eth1', 1, mock_switch_a)
+        mock_interface_b = get_interface_mock('s2-eth1', 1, mock_switch_b)
+        mock_link = get_link_mock(mock_interface_a, mock_interface_b)
         mock_link.id = link_id
-        self.napp.links = {link_id: mock_link}
-        self.napp.links_state = {link_id: {'enabled': True}}
-        # enable link
-        self.napp.restore_network_status(mock_link)
-        self.assertEqual(mock_link.enable.call_count, 1)
-
-        # disable link
-        self.napp.links_state = {link_id: {"enabled": False}}
-        self.napp._verified_links = []
-        self.napp.restore_network_status(mock_link)
-        self.assertEqual(mock_link.disable.call_count, 1)
+        with patch('napps.kytos.topology.main.Main._get_link_or_create',
+                   return_value=mock_link):
+            # enable link
+            link_attrs['enabled'] = True
+            self.napp.links = {link_id: mock_link}
+            self.napp._load_link(link_attrs)
+            self.assertEqual(mock_link.enable.call_count, 1)
+            # disable link
+            link_attrs['enabled'] = False
+            self.napp.links = {link_id: mock_link}
+            self.napp._load_link(link_attrs)
+            self.assertEqual(mock_link.disable.call_count, 1)
 
-    def test_fail_restore_link(self):
-        """Test fail restore_link."""
-        dpid = '00:00:00:00:00:00:00:01'
+    @patch('napps.kytos.topology.main.Main._get_link_or_create')
+    def test_fail_load_link(self, get_link_or_create_mock):
+        """Test fail load_link."""
+        dpid_a = '00:00:00:00:00:00:00:01'
         dpid_b = '00:00:00:00:00:00:00:02'
         link_id = '4d42dc08522'
-        link_id_fail = '4cd52'
-        mock_switch_a = get_switch_mock(dpid)
+        mock_switch_a = get_switch_mock(dpid_a)
         mock_switch_b = get_switch_mock(dpid_b)
         mock_interface_a_1 = get_interface_mock('s1-eth1', 1, mock_switch_a)
         mock_interface_b_1 = get_interface_mock('s2-eth1', 1, mock_switch_b)
         mock_link = get_link_mock(mock_interface_a_1, mock_interface_b_1)
         mock_link.id = link_id
         self.napp.links = {link_id: mock_link}
-        self.napp.links_state = {link_id: {"enabled": True}}
-        with self.assertRaises(RestoreError):
-            self.napp._restore_link(link_id_fail)
-
-        self.napp.links_state = {link_id_fail: {"enabled": True}}
-        with self.assertRaises(RestoreError):
-            self.napp._restore_link(link_id_fail)
-
-    def test_fail_restore_switch(self):
-        """Test fail restore_switch."""
-        dpid = '00:00:00:00:00:00:00:01'
-        dpid_fail = '00:00:00:00:00:00:00:06'
-        mock_switch = get_switch_mock(dpid)
-        mock_switch.id = dpid
-        mock_interface = get_interface_mock('s1-eth1', 1, mock_switch)
-        mock_switch.interfaces = {1: mock_interface}
-        self.napp.controller.switche = {dpid: mock_switch}
-        self.napp.switches_state = {dpid: True}
-        self.napp.interfaces_state = {'00:00:00:00:00:00:00:01:1': (True,
-                                                                    True)}
-
+        get_link_or_create_mock.return_value = mock_link
+
+        link_attrs_fail = {
+            'enabled': True,
+            'endpoint_a': {
+                'switch': dpid_a,
+                'port_number': 999
+            },
+            'endpoint_b': {
+                'switch': dpid_b,
+                'port_number': 999
+            }
+        }
         with self.assertRaises(RestoreError):
-            self.napp._restore_switch(dpid_fail)
-
-        self.napp.switches_state = {dpid_fail: True}
+            self.napp._load_link(link_attrs_fail)
+
+        link_attrs_fail = {
+            'enabled': True,
+            'endpoint_a': {
+                'switch': '00:00:00:00:00:00:00:99',
+                'port_number': 1
+            },
+            'endpoint_b': {
+                'switch': '00:00:00:00:00:00:00:77',
+                'port_number': 1
+            }
+        }
         with self.assertRaises(RestoreError):
-            self.napp._restore_switch(dpid_fail)
+            self.napp._load_link(link_attrs_fail)
 
     @patch('napps.kytos.topology.main.Main.save_status_on_storehouse')
     def test_enable_switch(self, mock_save_status):

From 507c0da207800bae05a9ffc2713b9f531db7ec29 Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Fri, 11 Jun 2021 22:00:39 -0400
Subject: [PATCH 03/28] saving the topology when elements are added and using
 Lock to avoid race conditions

---
 main.py                 | 38 ++++++++++++++++++++++++++++----------
 tests/unit/test_main.py | 23 +++++++++++++++++++----
 2 files changed, 47 insertions(+), 14 deletions(-)

diff --git a/main.py b/main.py
index 85f0c3d..581bb3a 100644
--- a/main.py
+++ b/main.py
@@ -4,6 +4,7 @@
 """
 import time
 from datetime import datetime, timezone
+from threading import Lock
 
 from flask import jsonify, request
 from werkzeug.exceptions import BadRequest, UnsupportedMediaType
@@ -41,6 +42,8 @@ def setup(self):
 
         self.storehouse = StoreHouse(self.controller)
 
+        self._lock = Lock()
+
     def execute(self):
         """Execute once when the napp is running."""
         self._load_network_status()
@@ -145,6 +148,17 @@ def _load_switch(self, switch_id, switch_att):
             interface.lldp = iface_att['lldp']
             switch.update_interface(interface)
             self.update_instance_metadata(interface)
+            name = 'kytos/topology.port.created'
+            event = KytosEvent(name=name, content={
+                                              'switch': switch_id,
+                                              'port': interface.port_number,
+                                              'port_description': {
+                                                  'alias': interface.name,
+                                                  'mac': interface.address,
+                                                  'state': interface.state
+                                                  }
+                                              })
+            self.controller.buffers.app.put(event)
 
     def _load_link(self, link_att):
         dpid_a = link_att['endpoint_a']['switch']
@@ -494,6 +508,7 @@ def handle_new_switch(self, event):
         switch = event.content['switch']
         switch.activate()
         log.debug('Switch %s added to the Topology.', switch.id)
+        self.save_status_on_storehouse()
         self.notify_topology_update()
         self.update_instance_metadata(switch)
         if switch.is_enabled():
@@ -526,6 +541,7 @@ def handle_interface_up(self, event):
     def handle_interface_created(self, event):
         """Update the topology based on a Port Create event."""
         self.handle_interface_up(event)
+        self.save_status_on_storehouse()
 
     def handle_interface_down(self, event):
         """Update the topology based on a Port Modify event.
@@ -639,6 +655,7 @@ def add_links(self, event):
         interface_b.nni = True
 
         self.notify_topology_update()
+        self.save_status_on_storehouse()
 
     # def add_host(self, event):
     #    """Update the topology with a new Host."""
@@ -661,16 +678,17 @@ def add_links(self, event):
     @listen_to('.*.network_status.updated')
     def save_status_on_storehouse(self, event=None):
         """Save the network administrative status using storehouse."""
-        status = self._get_switches_dict()
-        status['id'] = 'network_status'
-        if event:
-            content = event.content
-            log.info(f"Storing the administrative state of the"
-                     f" {content['attribute']} attribute to"
-                     f" {content['state']} in the interfaces"
-                     f" {content['interface_ids']}")
-        status.update(self._get_links_dict())
-        self.storehouse.save_status(status)
+        with self._lock:
+            status = self._get_switches_dict()
+            status['id'] = 'network_status'
+            if event:
+                content = event.content
+                log.info(f"Storing the administrative state of the"
+                         f" {content['attribute']} attribute to"
+                         f" {content['state']} in the interfaces"
+                         f" {content['interface_ids']}")
+            status.update(self._get_links_dict())
+            self.storehouse.save_status(status)
 
     def notify_switch_enabled(self, dpid):
         """Send an event to notify that a switch is enabled."""
diff --git a/tests/unit/test_main.py b/tests/unit/test_main.py
index 3bd7704..0aa9dbe 100644
--- a/tests/unit/test_main.py
+++ b/tests/unit/test_main.py
@@ -320,8 +320,11 @@ def test_load_network_status_fail_link(self, *args):
         error = 'Error loading link: xpto'
         mock_log.error.assert_called_with(error)
 
-    def test_load_switch(self):
+    @patch('napps.kytos.topology.main.KytosEvent')
+    @patch('kytos.core.buffers.KytosEventBuffer.put')
+    def test_load_switch(self, *args):
         """Test _load_switch."""
+        (mock_buffers_put, mock_event) = args
         dpid_a = "00:00:00:00:00:00:00:01"
         dpid_x = "00:00:00:00:00:00:00:XX"
         iface_a = f'{dpid_a}:1'
@@ -355,6 +358,9 @@ def test_load_switch(self):
         self.assertEqual(len(switch.interfaces), 1)
         self.assertIn(1, switch.interfaces)
         self.assertNotIn(2, switch.interfaces)
+        mock_event.assert_called()
+        mock_buffers_put.assert_called()
+
         interface = switch.interfaces[1]
         self.assertEqual(interface.id, iface_a)
         self.assertEqual(interface.switch.id, dpid_a)
@@ -992,9 +998,12 @@ def test_delete_link_metadata(self, mock_metadata_changes):
 
     @patch('napps.kytos.topology.main.Main.notify_topology_update')
     @patch('napps.kytos.topology.main.Main.update_instance_metadata')
+    @patch('napps.kytos.topology.main.StoreHouse.save_status')
     def test_handle_new_switch(self, *args):
         """Test handle_new_switch."""
-        (mock_instance_metadata, mock_notify_topology_update) = args
+        (mock_instance_metadata, mock_notify_topology_update,
+         mock_save_status) = args
+        mock_save_status.return_value = True
         mock_event = MagicMock()
         mock_switch = create_autospec(Switch)
         mock_event.content['switch'] = mock_switch
@@ -1025,8 +1034,11 @@ def test_handle_interface_up(self, *args):
         mock_instance_metadata.assert_called()
 
     @patch('napps.kytos.topology.main.Main.handle_interface_up')
-    def test_handle_interface_created(self, mock_handle_interface_up):
+    @patch('napps.kytos.topology.main.StoreHouse.save_status')
+    def test_handle_interface_created(self, *args):
         """Test handle interface created."""
+        (mock_handle_interface_up, mock_save_status) = args
+        mock_save_status.return_value = True
         mock_event = MagicMock()
         self.napp.handle_interface_created(mock_event)
         mock_handle_interface_up.assert_called()
@@ -1099,9 +1111,12 @@ def test_interface_link_down(self, *args):
 
     @patch('napps.kytos.topology.main.Main._get_link_or_create')
     @patch('napps.kytos.topology.main.Main.notify_topology_update')
+    @patch('napps.kytos.topology.main.StoreHouse.save_status')
     def test_add_links(self, *args):
         """Test add_links."""
-        (mock_notify_topology_update, mock_get_link_or_create) = args
+        (mock_notify_topology_update, mock_get_link_or_create,
+         mock_save_status) = args
+        mock_save_status.return_value = True
         mock_event = MagicMock()
         self.napp.add_links(mock_event)
         mock_get_link_or_create.assert_called()

From bccb7115165c6d3098218f22d7fadbd62b602905 Mon Sep 17 00:00:00 2001
From: Antonio Francisco <ajoaoff@gmail.com>
Date: Tue, 15 Jun 2021 08:42:07 -0300
Subject: [PATCH 04/28] Create github action to publish openAPI

---
 .github/workflows/main.yml | 31 +++++++++++++++++++++++++++++++
 1 file changed, 31 insertions(+)
 create mode 100644 .github/workflows/main.yml

diff --git a/.github/workflows/main.yml b/.github/workflows/main.yml
new file mode 100644
index 0000000..c1f7579
--- /dev/null
+++ b/.github/workflows/main.yml
@@ -0,0 +1,31 @@
+# This is a basic workflow to help you get started with Actions
+
+name: Copy OpenAPI to GitHub Pages
+
+# Controls when the action will run. 
+on:
+  # Triggers the workflow on push or pull request events but only for the master branch
+  push:
+    branches: [ master ]
+  # Allows you to run this workflow manually from the Actions tab
+  workflow_dispatch:
+
+# A workflow run is made up of one or more jobs that can run sequentially or in parallel
+jobs:
+  copy-file:
+    # The type of runner that the job will run on
+    runs-on: ubuntu-latest
+
+    # Steps represent a sequence of tasks that will be executed as part of the job
+    steps:
+      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
+      - uses: actions/checkout@v2
+
+      # Runs a single command using the runners shell
+      - name: Pushes openapi.yml
+        uses: dmnemec/copy_file_to_another_repo_action@v1.1.1
+        with:
+          source_file: 'openapi.yml'
+          destination_repo: 'kytos-ng/kytos-ng.github.io'
+          destination_folder: 'topology'
+          commit_message: 'Pushing topology openapi.yml'

From b49bb4290814c93c02d89fd1491ec8d8b4cfa9a9 Mon Sep 17 00:00:00 2001
From: Antonio Francisco <ajoaoff@gmail.com>
Date: Tue, 15 Jun 2021 08:44:48 -0300
Subject: [PATCH 05/28] Update main.yml

Add option destination_branch
---
 .github/workflows/main.yml | 1 +
 1 file changed, 1 insertion(+)

diff --git a/.github/workflows/main.yml b/.github/workflows/main.yml
index c1f7579..952ae42 100644
--- a/.github/workflows/main.yml
+++ b/.github/workflows/main.yml
@@ -28,4 +28,5 @@ jobs:
           source_file: 'openapi.yml'
           destination_repo: 'kytos-ng/kytos-ng.github.io'
           destination_folder: 'topology'
+          destination_branch: 'master'
           commit_message: 'Pushing topology openapi.yml'

From d0395236816de429e57127ea23cba8078d76bb03 Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Tue, 6 Jul 2021 10:15:59 -0400
Subject: [PATCH 06/28] loading network status when storehouse is load (which
 can happens before the topology)

---
 main.py | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/main.py b/main.py
index 581bb3a..fe9b4fd 100644
--- a/main.py
+++ b/main.py
@@ -44,9 +44,11 @@ def setup(self):
 
         self._lock = Lock()
 
+    @listen_to('kytos/storehouse.loaded')
     def execute(self):
         """Execute once when the napp is running."""
-        self._load_network_status()
+        with self._lock:
+            self._load_network_status()
 
     def shutdown(self):
         """Do nothing."""

From 0ed7631043015b0aa1f0674dc0d88ea8c1c1b824 Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Tue, 6 Jul 2021 10:17:16 -0400
Subject: [PATCH 07/28] saving topology status only when a new link is
 discovered (instead of every event from of_lldp)

---
 main.py | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/main.py b/main.py
index fe9b4fd..ee0569d 100644
--- a/main.py
+++ b/main.py
@@ -645,11 +645,17 @@ def add_links(self, event):
         interface_b = event.content['interface_b']
 
         try:
-            link = self._get_link_or_create(interface_a, interface_b)
+            link = Link(interface_a, interface_b)
         except KytosLinkCreationError as err:
             log.error(f'Error creating link: {err}.')
             return
 
+        if link.id in self.links:
+            log.debug(f'Already existing link id={link.id}')
+            return
+
+        self.links[link.id] = link
+
         interface_a.update_link(link)
         interface_b.update_link(link)
 

From 9b8815cd71e877c39fad22df9f9cd4c53f64a262 Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Fri, 13 Aug 2021 10:46:06 -0300
Subject: [PATCH 08/28] removing storehouse save from auto-discovery functions
 (the admin status will save only when requested by the user)

---
 main.py | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/main.py b/main.py
index ee0569d..afc741d 100644
--- a/main.py
+++ b/main.py
@@ -510,7 +510,6 @@ def handle_new_switch(self, event):
         switch = event.content['switch']
         switch.activate()
         log.debug('Switch %s added to the Topology.', switch.id)
-        self.save_status_on_storehouse()
         self.notify_topology_update()
         self.update_instance_metadata(switch)
         if switch.is_enabled():
@@ -543,7 +542,6 @@ def handle_interface_up(self, event):
     def handle_interface_created(self, event):
         """Update the topology based on a Port Create event."""
         self.handle_interface_up(event)
-        self.save_status_on_storehouse()
 
     def handle_interface_down(self, event):
         """Update the topology based on a Port Modify event.
@@ -663,7 +661,6 @@ def add_links(self, event):
         interface_b.nni = True
 
         self.notify_topology_update()
-        self.save_status_on_storehouse()
 
     # def add_host(self, event):
     #    """Update the topology with a new Host."""

From 1bad9f010d2166c50b5a522197485849dea07b64 Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Fri, 13 Aug 2021 10:48:16 -0300
Subject: [PATCH 09/28] change tests back to not consider storehouse save
 status when handling automatic events

---
 tests/unit/test_main.py | 15 +++------------
 1 file changed, 3 insertions(+), 12 deletions(-)

diff --git a/tests/unit/test_main.py b/tests/unit/test_main.py
index 0aa9dbe..66266e1 100644
--- a/tests/unit/test_main.py
+++ b/tests/unit/test_main.py
@@ -998,12 +998,9 @@ def test_delete_link_metadata(self, mock_metadata_changes):
 
     @patch('napps.kytos.topology.main.Main.notify_topology_update')
     @patch('napps.kytos.topology.main.Main.update_instance_metadata')
-    @patch('napps.kytos.topology.main.StoreHouse.save_status')
     def test_handle_new_switch(self, *args):
         """Test handle_new_switch."""
-        (mock_instance_metadata, mock_notify_topology_update,
-         mock_save_status) = args
-        mock_save_status.return_value = True
+        (mock_instance_metadata, mock_notify_topology_update) = args
         mock_event = MagicMock()
         mock_switch = create_autospec(Switch)
         mock_event.content['switch'] = mock_switch
@@ -1034,11 +1031,8 @@ def test_handle_interface_up(self, *args):
         mock_instance_metadata.assert_called()
 
     @patch('napps.kytos.topology.main.Main.handle_interface_up')
-    @patch('napps.kytos.topology.main.StoreHouse.save_status')
-    def test_handle_interface_created(self, *args):
+    def test_handle_interface_created(self, mock_handle_interface_up):
         """Test handle interface created."""
-        (mock_handle_interface_up, mock_save_status) = args
-        mock_save_status.return_value = True
         mock_event = MagicMock()
         self.napp.handle_interface_created(mock_event)
         mock_handle_interface_up.assert_called()
@@ -1111,12 +1105,9 @@ def test_interface_link_down(self, *args):
 
     @patch('napps.kytos.topology.main.Main._get_link_or_create')
     @patch('napps.kytos.topology.main.Main.notify_topology_update')
-    @patch('napps.kytos.topology.main.StoreHouse.save_status')
     def test_add_links(self, *args):
         """Test add_links."""
-        (mock_notify_topology_update, mock_get_link_or_create,
-         mock_save_status) = args
-        mock_save_status.return_value = True
+        (mock_notify_topology_update, mock_get_link_or_create) = args
         mock_event = MagicMock()
         self.napp.add_links(mock_event)
         mock_get_link_or_create.assert_called()

From 1fda96da9feb122b934852ce655fab5616973dd0 Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Fri, 13 Aug 2021 10:48:59 -0300
Subject: [PATCH 10/28] using controller.get_switch_or_create and
 switch.update_or_create_interface to create switches/interfaces

---
 main.py | 40 +++++++++++++++++-----------------------
 1 file changed, 17 insertions(+), 23 deletions(-)

diff --git a/main.py b/main.py
index afc741d..37e8903 100644
--- a/main.py
+++ b/main.py
@@ -121,10 +121,7 @@ def _get_link_from_interface(self, interface):
 
     def _load_switch(self, switch_id, switch_att):
         log.info(f'Loading switch from storehouse dpid={switch_id}')
-        switch = Switch(dpid=switch_id)
-        self.controller.add_new_switch(switch)
-        # workaround so switch.is_active() returns False
-        switch.lastseen = datetime(1, 1, 1, 0, 0, 0, 0, timezone.utc)
+        switch = self.controller.get_switch_or_create(switch_id)
         if switch_att['enabled']:
             switch.enable()
         else:
@@ -135,20 +132,19 @@ def _load_switch(self, switch_id, switch_att):
         switch.description['serial'] = switch_att.get('serial', '')
         switch.description['data_path'] = switch_att.get('data_path', '')
         self.update_instance_metadata(switch)
+
         for iface_id, iface_att in switch_att.get('interfaces', {}).items():
             log.info(f'Loading interface iface_id={iface_id}')
-            interface = Interface(name=iface_att['name'],
-                                  port_number=iface_att['port_number'],
-                                  address=iface_att.get('mac', None),
-                                  speed=iface_att.get('speed', None),
-                                  switch=switch)
-            interface.deactivate()
+            interface = switch.update_or_create_interface(
+                            port_no=iface_att['port_number'],
+                            name=iface_att['name'],
+                            address=iface_att.get('mac', None),
+                            speed=iface_att.get('speed', None))
             if iface_att['enabled']:
                 interface.enable()
             else:
                 interface.disable()
             interface.lldp = iface_att['lldp']
-            switch.update_interface(interface)
             self.update_instance_metadata(interface)
             name = 'kytos/topology.port.created'
             event = KytosEvent(name=name, content={
@@ -210,21 +206,19 @@ def _load_network_status(self):
 
         log.debug("_load_network_status switches=%s" % switches)
         for switch_id, switch_att in switches.items():
-            if switch_id not in self.controller.switches:
-                try:
-                    self._load_switch(switch_id, switch_att)
-                # pylint: disable=broad-except
-                except Exception as err:
-                    log.error(f'Error loading switch: {err}')
+            try:
+                self._load_switch(switch_id, switch_att)
+            # pylint: disable=broad-except
+            except Exception as err:
+                log.error(f'Error loading switch: {err}')
 
         log.debug("_load_network_status links=%s" % links)
         for link_id, link_att in links.items():
-            if link_id not in self.links:
-                try:
-                    self._load_link(link_att)
-                # pylint: disable=broad-except
-                except Exception as err:
-                    log.error(f'Error loading link: {err}')
+            try:
+                self._load_link(link_att)
+            # pylint: disable=broad-except
+            except Exception as err:
+                log.error(f'Error loading link: {err}')
 
     @rest('v3/')
     def get_topology(self):

From f51b141b803c9f480a14f22a882d48e166aa1ac5 Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Fri, 13 Aug 2021 10:54:47 -0300
Subject: [PATCH 11/28] rollback add_links change to use
 self._get_link_or_create()

---
 main.py | 8 +-------
 1 file changed, 1 insertion(+), 7 deletions(-)

diff --git a/main.py b/main.py
index 37e8903..f44435d 100644
--- a/main.py
+++ b/main.py
@@ -637,17 +637,11 @@ def add_links(self, event):
         interface_b = event.content['interface_b']
 
         try:
-            link = Link(interface_a, interface_b)
+            link = self._get_link_or_create(interface_a, interface_b)
         except KytosLinkCreationError as err:
             log.error(f'Error creating link: {err}.')
             return
 
-        if link.id in self.links:
-            log.debug(f'Already existing link id={link.id}')
-            return
-
-        self.links[link.id] = link
-
         interface_a.update_link(link)
         interface_b.update_link(link)
 

From 6667d30ebebc6bd2166bc374c6532f3128d752d9 Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Fri, 13 Aug 2021 10:55:25 -0300
Subject: [PATCH 12/28] adding napp storehouse.loaded in the list of events

---
 tests/unit/test_main.py | 1 +
 1 file changed, 1 insertion(+)

diff --git a/tests/unit/test_main.py b/tests/unit/test_main.py
index 66266e1..447cbff 100644
--- a/tests/unit/test_main.py
+++ b/tests/unit/test_main.py
@@ -41,6 +41,7 @@ def test_get_event_listeners(self):
                            'kytos/maintenance.end_link',
                            'kytos/maintenance.start_switch',
                            'kytos/maintenance.end_switch',
+                           'kytos/storehouse.loaded',
                            '.*.network_status.updated',
                            '.*.interface.is.nni',
                            '.*.connection.lost',

From d789a034ba500dada66a582ca673d016489b1fc8 Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Fri, 13 Aug 2021 11:07:15 -0300
Subject: [PATCH 13/28] fix pylint errors

---
 main.py | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/main.py b/main.py
index f44435d..8aa4d1d 100644
--- a/main.py
+++ b/main.py
@@ -3,7 +3,6 @@
 Manage the network topology
 """
 import time
-from datetime import datetime, timezone
 from threading import Lock
 
 from flask import jsonify, request
@@ -218,7 +217,7 @@ def _load_network_status(self):
                 self._load_link(link_att)
             # pylint: disable=broad-except
             except Exception as err:
-                log.error(f'Error loading link: {err}')
+                log.error(f'Error loading link {link_id}: {err}')
 
     @rest('v3/')
     def get_topology(self):

From 0af77c68bace84227eb7c91a5fa3a1f21affb1c3 Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Mon, 23 Aug 2021 17:52:41 -0300
Subject: [PATCH 14/28] fixing dependencies for kytos-ng repo

---
 requirements/dev.in  | 4 ++--
 requirements/dev.txt | 4 ++--
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/requirements/dev.in b/requirements/dev.in
index bf24e6c..731988f 100644
--- a/requirements/dev.in
+++ b/requirements/dev.in
@@ -1,3 +1,3 @@
--e git+https://github.com/kytos/python-openflow.git#egg=python-openflow
--e git+https://github.com/kytos/kytos.git#egg=kytos
+-e git+https://github.com/kytos-ng/python-openflow.git#egg=python-openflow
+-e git+https://github.com/kytos-ng/kytos.git#egg=kytos
 -e .[dev]
diff --git a/requirements/dev.txt b/requirements/dev.txt
index 6ec2b47..8243be5 100644
--- a/requirements/dev.txt
+++ b/requirements/dev.txt
@@ -4,9 +4,9 @@
 #
 #    pip-compile --output-file requirements/dev2.txt requirements/dev.in
 #
--e git+https://github.com/kytos/kytos.git#egg=kytos
+-e git+https://github.com/kytos-ng/kytos.git#egg=kytos
 -e .
--e git+https://github.com/kytos/python-openflow.git#egg=python-openflow
+-e git+https://github.com/kytos-ng/python-openflow.git#egg=python-openflow
 astroid==2.3.3            # via pylint
 click==7.1.1              # via pip-tools
 coverage==5.0.3

From a67ff8e2289ea08ab757fbacdc20c8cf26844d8f Mon Sep 17 00:00:00 2001
From: Antonio Francisco <antonio@ansp.br>
Date: Mon, 23 Aug 2021 19:49:38 -0300
Subject: [PATCH 15/28] Remove github actions

---
 .github/workflows/main.yml | 32 --------------------------------
 1 file changed, 32 deletions(-)
 delete mode 100644 .github/workflows/main.yml

diff --git a/.github/workflows/main.yml b/.github/workflows/main.yml
deleted file mode 100644
index 952ae42..0000000
--- a/.github/workflows/main.yml
+++ /dev/null
@@ -1,32 +0,0 @@
-# This is a basic workflow to help you get started with Actions
-
-name: Copy OpenAPI to GitHub Pages
-
-# Controls when the action will run. 
-on:
-  # Triggers the workflow on push or pull request events but only for the master branch
-  push:
-    branches: [ master ]
-  # Allows you to run this workflow manually from the Actions tab
-  workflow_dispatch:
-
-# A workflow run is made up of one or more jobs that can run sequentially or in parallel
-jobs:
-  copy-file:
-    # The type of runner that the job will run on
-    runs-on: ubuntu-latest
-
-    # Steps represent a sequence of tasks that will be executed as part of the job
-    steps:
-      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
-      - uses: actions/checkout@v2
-
-      # Runs a single command using the runners shell
-      - name: Pushes openapi.yml
-        uses: dmnemec/copy_file_to_another_repo_action@v1.1.1
-        with:
-          source_file: 'openapi.yml'
-          destination_repo: 'kytos-ng/kytos-ng.github.io'
-          destination_folder: 'topology'
-          destination_branch: 'master'
-          commit_message: 'Pushing topology openapi.yml'

From fdc5af04077f84b5f9e69180e526ff942eeac7f2 Mon Sep 17 00:00:00 2001
From: Antonio Francisco <ajoaoff@gmail.com>
Date: Mon, 23 Aug 2021 19:45:53 -0300
Subject: [PATCH 16/28] Add a reason to link status change event

Link status changes now include a reason attribute
indicating why the status changed.
Fixes #14
---
 main.py                 | 29 ++++++++++++++++++++---------
 tests/unit/test_main.py |  4 ++--
 2 files changed, 22 insertions(+), 11 deletions(-)

diff --git a/main.py b/main.py
index 70c7f28..6f88e29 100644
--- a/main.py
+++ b/main.py
@@ -143,7 +143,7 @@ def _restore_link(self, link_id):
         log.info(f'The state of link {link.id} has been restored.')
         self.notify_topology_update()
         self.update_instance_metadata(link)
-        self.notify_link_status_change(link)
+        self.notify_link_status_change(link, reason='from storehouse')
 
     def _restore_switch(self, switch_id):
         """Restore switch's administrative state from storehouse."""
@@ -474,7 +474,10 @@ def enable_link(self, link_id):
         except KeyError:
             return jsonify("Link not found"), 404
         self.save_status_on_storehouse()
-        self.notify_link_status_change(self.links[link_id])
+        self.notify_link_status_change(
+            self.links[link_id],
+            reason='link enabled'
+        )
         return jsonify("Operation successful"), 201
 
     @rest('v3/links/<link_id>/disable', methods=['POST'])
@@ -485,7 +488,10 @@ def disable_link(self, link_id):
         except KeyError:
             return jsonify("Link not found"), 404
         self.save_status_on_storehouse()
-        self.notify_link_status_change(self.links[link_id])
+        self.notify_link_status_change(
+            self.links[link_id],
+            reason='link disabled'
+        )
         return jsonify("Operation successful"), 201
 
     @rest('v3/links/<link_id>/metadata')
@@ -628,7 +634,7 @@ def handle_link_up(self, interface):
                     now - last_status_change >= self.link_up_timer:
                 self.notify_topology_update()
                 self.update_instance_metadata(link)
-                self.notify_link_status_change(link)
+                self.notify_link_status_change(link, reason='link up')
 
     @listen_to('.*.switch.interface.link_down')
     def handle_interface_link_down(self, event):
@@ -658,7 +664,7 @@ def handle_link_down(self, interface):
             link.deactivate()
             link.update_metadata('last_status_change', time.time())
             self.notify_topology_update()
-            self.notify_link_status_change(link)
+            self.notify_link_status_change(link, reason='link down')
 
     @listen_to('.*.interface.is.nni')
     def add_links(self, event):
@@ -732,14 +738,19 @@ def notify_topology_update(self):
                                                self._get_topology()})
         self.controller.buffers.app.put(event)
 
-    def notify_link_status_change(self, link):
+    def notify_link_status_change(self, link, reason='not given'):
         """Send an event to notify about a status change on a link."""
         name = 'kytos/topology.'
         if link.is_active() and link.is_enabled():
             status = 'link_up'
         else:
             status = 'link_down'
-        event = KytosEvent(name=name+status, content={'link': link})
+        event = KytosEvent(
+            name=name+status,
+            content={
+                'link': link,
+                'reason': reason
+            })
         self.controller.buffers.app.put(event)
 
     def notify_metadata_changes(self, obj, action):
@@ -876,7 +887,7 @@ def handle_link_maintenance_start(self, event):
             link.endpoint_b.deactivate()
             link.endpoint_a.disable()
             link.endpoint_b.disable()
-            self.notify_link_status_change(link)
+            self.notify_link_status_change(link, reason='maintenance')
 
     @listen_to('kytos/maintenance.end_link')
     def handle_link_maintenance_end(self, event):
@@ -896,4 +907,4 @@ def handle_link_maintenance_end(self, event):
             link.endpoint_b.activate()
             link.endpoint_a.enable()
             link.endpoint_b.enable()
-            self.notify_link_status_change(link)
+            self.notify_link_status_change(link, reason='maintenance')
diff --git a/tests/unit/test_main.py b/tests/unit/test_main.py
index 7d98502..482b777 100644
--- a/tests/unit/test_main.py
+++ b/tests/unit/test_main.py
@@ -1038,7 +1038,7 @@ def test_handle_link_maintenance_start(self, status_change_mock):
         event.content = content
         self.napp.links = {2: link1, 4: link3}
         self.napp.handle_link_maintenance_start(event)
-        status_change_mock.assert_called_once_with(link1)
+        status_change_mock.assert_called_once_with(link1, reason='maintenance')
 
     @patch('napps.kytos.topology.main.Main.notify_link_status_change')
     def test_handle_link_maintenance_end(self, status_change_mock):
@@ -1054,7 +1054,7 @@ def test_handle_link_maintenance_end(self, status_change_mock):
         event.content = content
         self.napp.links = {2: link1, 4: link3}
         self.napp.handle_link_maintenance_end(event)
-        status_change_mock.assert_called_once_with(link1)
+        status_change_mock.assert_called_once_with(link1, reason='maintenance')
 
     @patch('napps.kytos.topology.main.Main.handle_link_down')
     def test_handle_switch_maintenance_start(self, handle_link_down_mock):

From fa1eb20e4f93c313819230dcaecf19d4512be067 Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Mon, 7 Jun 2021 10:13:24 -0400
Subject: [PATCH 17/28] changing the restore topology routine to load the
 switches, interfaces and links on Kytos startup

---
 main.py | 199 ++++++++++++++++++++++----------------------------------
 1 file changed, 79 insertions(+), 120 deletions(-)

diff --git a/main.py b/main.py
index 6f88e29..719ab8e 100644
--- a/main.py
+++ b/main.py
@@ -3,6 +3,7 @@
 Manage the network topology
 """
 import time
+from datetime import datetime, timezone
 
 from flask import jsonify, request
 from werkzeug.exceptions import BadRequest, UnsupportedMediaType
@@ -19,8 +20,6 @@
 from napps.kytos.topology.storehouse import StoreHouse
 
 DEFAULT_LINK_UP_TIMER = 10
-DEFAULT_INTERFACE_RESTORE_TIMER = 2
-RESTORE_INTERFACE_ATTEMPTS = 20
 
 
 class Main(KytosNApp):  # pylint: disable=too-many-public-methods
@@ -33,14 +32,8 @@ def setup(self):
         """Initialize the NApp's links list."""
         self.links = {}
         self.store_items = {}
-        self.switches_state = {}
-        self.interfaces_state = {}
-        self.links_state = {}
-        self._verified_links = []
         self.link_up_timer = getattr(settings, 'LINK_UP_TIMER',
                                      DEFAULT_LINK_UP_TIMER)
-        self.interface_restore = getattr(settings, 'INTERFACE_RESTORE_TIMER',
-                                         DEFAULT_INTERFACE_RESTORE_TIMER)
 
         self.verify_storehouse('switches')
         self.verify_storehouse('interfaces')
@@ -121,94 +114,67 @@ def _get_link_from_interface(self, interface):
                 return link
         return None
 
-    def _restore_link(self, link_id):
-        """Restore link's administrative state from storehouse."""
-        try:
-            state = self.links_state[link_id]
-        except KeyError:
-            error = (f'The link {link_id} has no stored '
-                     'administrative state to be restored.')
-            raise RestoreError(error)
-
-        try:
-            link = self.links[link_id]
-            if state['enabled']:
-                link.enable()
-            else:
-                link.disable()
-        except KeyError:
-            error = ('Error restoring link status.'
-                     f'The link {link_id} does not exist.')
-            raise RestoreError(error)
-        log.info(f'The state of link {link.id} has been restored.')
-        self.notify_topology_update()
-        self.update_instance_metadata(link)
-        self.notify_link_status_change(link, reason='from storehouse')
-
-    def _restore_switch(self, switch_id):
-        """Restore switch's administrative state from storehouse."""
-        try:
-            state = self.switches_state[switch_id]
-        except KeyError:
-            error = (f'The switch {switch_id} has no stored'
-                     ' administrative state to be restored.')
-            raise RestoreError(error)
-
-        try:
-            switch = self.controller.switches[switch_id]
-        except KeyError:
-            # Maybe we should remove the switch from switches_state here
-            error = ('Error while restoring switches status. The '
-                     f'switch {switch_id} does not exist.')
-            raise RestoreError(error)
-
-        if state:
+    def _load_switch(self, switch_id, switch_att):
+        log.info(f'Loading switch from storehouse dpid={switch_id}')
+        switch = Switch(dpid=switch_id)
+        self.controller.add_new_switch(switch)
+        # workaround so switch.is_active() returns False
+        switch.lastseen = datetime(1, 1, 1, 0, 0, 0, 0, timezone.utc)
+        if switch_att['enabled']:
             switch.enable()
-            self.notify_switch_enabled(switch_id)
         else:
             switch.disable()
-            self.notify_switch_disabled(switch_id)
-
-        log.debug('Waiting to restore administrative state of switch '
-                  f'{switch_id} interfaces.')
-        i = 0
-        # wait to restore interfaces
-        while not switch.interfaces and i < RESTORE_INTERFACE_ATTEMPTS:
-            time.sleep(self.interface_restore)
-            i += 1
-        if not switch.interfaces:
-            error = ('Error restoring administrative state of switch '
-                     f'{switch_id} interfaces.')
-            raise RestoreError(error)
-
-        # restore interfaces
-        for interface_id in switch.interfaces:
-            iface_id = ":".join([switch_id, str(interface_id)])
-            # restore only the administrative state of saved interfaces
-            if iface_id not in self.interfaces_state:
-                error = ("The stored topology is different from the current "
-                         f"topology. The interface {iface_id} hasn't been "
-                         "stored.")
-                log.info(error)
-                continue
-            state = self.interfaces_state[iface_id]
-            iface_number = int(interface_id)
-            iface_status, lldp_status = state
-            try:
-                interface = switch.interfaces[iface_number]
-            except KeyError:
-                log.error('Error restoring interface status: '
-                          '%s does not exist.', iface_id)
-                continue
-
-            if iface_status:
+        switch.description['manufacturer'] = switch_att.get('manufacturer', '')
+        switch.description['hardware'] = switch_att.get('hardware', '')
+        switch.description['software'] = switch_att.get('software')
+        switch.description['serial'] = switch_att.get('serial', '')
+        switch.description['data_path'] = switch_att.get('data_path', '')
+        self.update_instance_metadata(switch)
+        for iface_id, iface_att in switch_att.get('interfaces', {}).items():
+            log.info(f'Loading interface iface_id={iface_id}')
+            interface = Interface(name=iface_att['name'],
+                                  port_number=iface_att['port_number'],
+                                  address=iface_att.get('mac', None),
+                                  speed=iface_att.get('speed', None),
+                                  switch=switch)
+            interface.deactivate()
+            if iface_att['enabled']:
                 interface.enable()
             else:
                 interface.disable()
-            interface.lldp = lldp_status
+            interface.lldp = iface_att['lldp']
+            switch.update_interface(interface)
             self.update_instance_metadata(interface)
 
-        log.info(f'The state of switch {switch_id} has been restored.')
+    def _load_link(self, link_att):
+        dpid_a = link_att['endpoint_a']['switch']
+        dpid_b = link_att['endpoint_b']['switch']
+        port_a = link_att['endpoint_a']['port_number']
+        port_b = link_att['endpoint_b']['port_number']
+        link_str = f'{dpid_a}:{port_a}-{dpid_b}:{port_b}'
+        log.info(f'Loading link from storehouse {link_str}')
+
+        try:
+            switch_a = self.controller.switches[dpid_a]
+            switch_b = self.controller.switches[dpid_b]
+            interface_a = switch_a.interfaces[port_a]
+            interface_b = switch_b.interfaces[port_b]
+        except Exception as err:
+            error = f'Fail to load endpoints for link {link_str}: {err}'
+            raise RestoreError(error)
+
+        link = self._get_link_or_create(interface_a, interface_b)
+
+        if link_att['enabled']:
+            link.enable()
+        else:
+            link.disable()
+
+        interface_a.update_link(link)
+        interface_b.update_link(link)
+        interface_a.nni = True
+        interface_b.nni = True
+        self.update_instance_metadata(link)
 
     # pylint: disable=attribute-defined-outside-init
     def _load_network_status(self):
@@ -216,26 +182,33 @@ def _load_network_status(self):
         try:
             status = self.storehouse.get_data()
         except FileNotFoundError as error:
-            log.info(error)
+            log.error(f'Fail to load network status from storehouse: {error}')
             return
-        if status:
-            switches = status['network_status']['switches']
-            self.links_state = status['network_status']['links']
-
-            for switch_id, switch_att in switches.items():
-                # get switches status
-                self.switches_state[switch_id] = switch_att['enabled']
-                iface = switch_att['interfaces']
-                # get interface status
-                for iface_id, iface_att in iface.items():
-                    enabled_value = iface_att['enabled']
-                    lldp_value = iface_att['lldp']
-                    self.interfaces_state[iface_id] = (enabled_value,
-                                                       lldp_value)
 
-        else:
-            error = 'There is no status saved to restore.'
-            log.info(error)
+        if not status:
+            log.info('There is no status saved to restore.')
+            return
+
+        switches = status['network_status']['switches']
+        links = status['network_status']['links']
+
+        log.debug("_load_network_status switches=%s" % switches)
+        for switch_id, switch_att in switches.items():
+            if switch_id not in self.controller.switches:
+                try:
+                    self._load_switch(switch_id, switch_att)
+                # pylint: disable=broad-except
+                except Exception as err:
+                    log.error(f'Error loading switch: {err}')
+
+        log.debug("_load_network_status links=%s" % links)
+        for link_id, link_att in links.items():
+            if link_id not in self.links:
+                try:
+                    self._load_link(link_att)
+                # pylint: disable=broad-except
+                except Exception as err:
+                    log.error(f'Error loading link: {err}')
 
     @rest('v3/')
     def get_topology(self):
@@ -245,18 +218,6 @@ def get_topology(self):
         """
         return jsonify(self._get_topology_dict())
 
-    def restore_network_status(self, obj):
-        """Restore the network administrative status saved in storehouse."""
-        try:
-            if isinstance(obj, Switch):
-                self._restore_switch(obj.id)
-            elif isinstance(obj, Link):
-                if obj.id not in self._verified_links:
-                    self._verified_links.append(obj.id)
-                    self._restore_link(obj.id)
-        except RestoreError as exc:
-            log.debug(exc)
-
     # Switch related methods
     @rest('v3/switches')
     def get_switches(self):
@@ -541,7 +502,6 @@ def handle_new_switch(self, event):
         log.debug('Switch %s added to the Topology.', switch.id)
         self.notify_topology_update()
         self.update_instance_metadata(switch)
-        self.restore_network_status(switch)
         if switch.is_enabled():
             self.notify_switch_enabled(switch.id)
 
@@ -685,7 +645,6 @@ def add_links(self, event):
         interface_b.nni = True
 
         self.notify_topology_update()
-        self.restore_network_status(link)
 
     # def add_host(self, event):
     #    """Update the topology with a new Host."""

From 221fd9567274c4d00dadaba08220527f99d6fe3f Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Tue, 8 Jun 2021 22:47:50 -0400
Subject: [PATCH 18/28] cleaning up settings and adjusting unit tests

---
 settings.py             |   2 -
 tests/unit/test_main.py | 398 ++++++++++++++++++++++++++++++----------
 2 files changed, 305 insertions(+), 95 deletions(-)

diff --git a/settings.py b/settings.py
index f756511..290b26d 100644
--- a/settings.py
+++ b/settings.py
@@ -7,5 +7,3 @@
 LINK_UP_TIMER = 10
 # Time (in seconds) to wait retrieve box from storehouse
 BOX_RESTORE_TIMER = 0.1
-# Time (in seconds) to wait before restore interfaces
-INTERFACE_RESTORE_TIMER = 2
diff --git a/tests/unit/test_main.py b/tests/unit/test_main.py
index 482b777..36f64fd 100644
--- a/tests/unit/test_main.py
+++ b/tests/unit/test_main.py
@@ -190,138 +190,350 @@ def test_get_topology(self):
     @patch('napps.kytos.topology.main.StoreHouse.get_data')
     def test_load_network_status(self, mock_storehouse_get_data):
         """Test _load_network_status."""
+        link_id = \
+            'cf0f4071be426b3f745027f5d22bc61f8312ae86293c9b28e7e66015607a9260'
+        dpid_a = '00:00:00:00:00:00:00:01'
+        dpid_b = '00:00:00:00:00:00:00:02'
         status = {
             'network_status': {
                 'id': 'network_status',
                 'links': {
-                    '4d42dc08522': {
+                    link_id: {
                         'enabled': True,
                         'endpoint_a': {
-                            'switch': '00:00:00:00:00:00:00:01',
-                            'id': '00:00:00:00:00:00:00:00:1'
+                            'switch': dpid_a,
+                            'port_number': 2
                         },
                         'endpoint_b': {
-                            'switch': '00:00:00:00:00:00:00:01',
-                            'id': '00:00:00:00:00:00:00:00:2'
+                            'switch': dpid_b,
+                            'port_number': 2
                         }
                     }
                 },
                 'switches': {
-                    '00:00:00:00:00:00:00:01': {
-                        'dpid': '00:00:00:00:00:00:00:01',
+                    dpid_a: {
+                        'dpid': dpid_a,
                         'enabled': True,
-                        'id': '00:00:00:00:00:00:00:01',
+                        'id': dpid_a,
                         'interfaces': {
-                            '00:00:00:00:00:00:00:01:1': {
+                            f'{dpid_a}:2': {
                                 'enabled': True,
                                 'lldp': True,
-                                'id': '00:00:00:00:00:00:00:00:1',
+                                'port_number': 2,
+                                'name': 's1-eth2'
+                            }
+                        }
+                    },
+                    dpid_b: {
+                        'dpid': dpid_b,
+                        'enabled': True,
+                        'id': dpid_b,
+                        'interfaces': {
+                            f'{dpid_b}:2': {
+                                'enabled': True,
+                                'lldp': True,
+                                'port_number': 2,
+                                'name': 's2-eth2'
                             }
                         }
                     }
                 }
             }
         }
-        switches_expected = {'00:00:00:00:00:00:00:01': True}
-        interfaces_expected = {'00:00:00:00:00:00:00:01:1': (True, True)}
+        switches_expected = [dpid_a, dpid_b]
+        interfaces_expected = [f'{dpid_a}:2', f'{dpid_b}:2']
+        links_expected = [link_id]
         mock_storehouse_get_data.return_value = status
         self.napp._load_network_status()
-        self.assertDictEqual(switches_expected, self.napp.switches_state)
-        self.assertDictEqual(interfaces_expected, self.napp.interfaces_state)
-        self.assertDictEqual(status['network_status']['links'],
-                             self.napp.links_state)
-
-    # pylint: disable=too-many-locals
-    def test_restore_network_status(self):
-        """Test restore_network_status."""
-        dpid = '00:00:00:00:00:00:00:01'
-        mock_switch = get_switch_mock(dpid)
-        mock_switch.id = dpid
-        mock_interface = get_interface_mock('s1-eth1', 1, mock_switch)
-        mock_switch.interfaces = {1: mock_interface}
-        self.napp.controller.switches = {dpid: mock_switch}
-        self.napp.switches_state = {dpid: True}
-        self.napp.interfaces_state = {'00:00:00:00:00:00:00:01:1': (True,
-                                                                    True)}
+        self.assertListEqual(switches_expected,
+                             list(self.napp.controller.switches.keys()))
+        interfaces = []
+        for switch in self.napp.controller.switches.values():
+            for iface in switch.interfaces.values():
+                interfaces.append(iface.id)
+        self.assertListEqual(interfaces_expected, interfaces)
+        self.assertListEqual(links_expected, list(self.napp.links.keys()))
 
-        # enable
-        self.napp.restore_network_status(mock_switch)
-        self.assertEqual(mock_switch.enable.call_count, 1)
-        self.assertEqual(mock_interface.enable.call_count, 1)
-        self.assertEqual(mock_interface.lldp, True)
-
-        # disable
-        self.napp.switches_state = {dpid: False}
-        self.napp.interfaces_state = {'00:00:00:00:00:00:00:01:1': (False,
-                                                                    False)}
-        self.napp.restore_network_status(mock_switch)
-        self.assertEqual(mock_switch.disable.call_count, 1)
-        self.assertEqual(mock_interface.disable.call_count, 1)
-        self.assertEqual(mock_interface.lldp, False)
+    @patch('napps.kytos.topology.main.StoreHouse.get_data')
+    @patch('napps.kytos.topology.main.log')
+    def test_load_network_status_fail(self, *args):
+        """Test _load_network_status failure."""
+        (mock_log, mock_storehouse_get_data) = args
+        mock_log.error.return_value = True
+        mock_storehouse_get_data.side_effect = FileNotFoundError('xpto')
+        self.napp._load_network_status()
+        error = 'Fail to load network status from storehouse: xpto'
+        mock_log.error.assert_called_with(error)
 
-    def test_restore_links(self):
-        """Test restore_link."""
-        dpid = '00:00:00:00:00:00:00:01'
-        dpid_b = '00:00:00:00:00:00:00:02'
+    @patch('napps.kytos.topology.main.StoreHouse.get_data')
+    @patch('napps.kytos.topology.main.log')
+    def test_load_network_status_does_nothing(self, *args):
+        """Test _load_network_status doing nothing."""
+        (mock_log, mock_storehouse_get_data) = args
+        mock_log.info.return_value = True
+        mock_storehouse_get_data.return_value = {}
+        self.napp._load_network_status()
+        error = 'There is no status saved to restore.'
+        mock_log.info.assert_called_with(error)
+
+    @patch('napps.kytos.topology.main.StoreHouse.get_data')
+    @patch('napps.kytos.topology.main.Main._load_switch')
+    @patch('napps.kytos.topology.main.log')
+    def test_load_network_status_fail_switch(self, *args):
+        """Test _load_network_status failure in switch."""
+        (mock_log, mock_load_switch, mock_get_data) = args
+        status = {
+            'network_status': {
+                'id': 'network_status',
+                'links': {},
+                'switches': {
+                    '1': {}
+                }
+            }
+        }
+        mock_log.error.return_value = True
+        mock_get_data.return_value = status
+        mock_load_switch.side_effect = Exception('xpto')
+        self.napp._load_network_status()
+        error = 'Error loading switch: xpto'
+        mock_log.error.assert_called_with(error)
+
+    @patch('napps.kytos.topology.main.StoreHouse.get_data')
+    @patch('napps.kytos.topology.main.Main._load_link')
+    @patch('napps.kytos.topology.main.log')
+    def test_load_network_status_fail_link(self, *args):
+        """Test _load_network_status failure in link."""
+        (mock_log, mock_load_link, mock_get_data) = args
+        status = {
+            'network_status': {
+                'id': 'network_status',
+                'switches': {},
+                'links': {
+                    '1': {}
+                }
+            }
+        }
+        mock_log.error.return_value = True
+        mock_get_data.return_value = status
+        mock_load_link.side_effect = Exception('xpto')
+        self.napp._load_network_status()
+        error = 'Error loading link: xpto'
+        mock_log.error.assert_called_with(error)
+
+    def test_load_switch(self):
+        """Test _load_switch."""
+        dpid_a = "00:00:00:00:00:00:00:01"
+        dpid_x = "00:00:00:00:00:00:00:XX"
+        iface_a = f'{dpid_a}:1'
+        switch_attrs = {
+            'dpid': dpid_a,
+            'enabled': True,
+            'id': dpid_a,
+            'interfaces': {
+                iface_a: {
+                    'enabled': True,
+                    'lldp': True,
+                    'id': iface_a,
+                    'switch': dpid_a,
+                    'name': 's2-eth1',
+                    'port_number': 1
+                }
+            }
+        }
+        self.napp._load_switch(dpid_a, switch_attrs)
+
+        self.assertEqual(len(self.napp.controller.switches), 1)
+        self.assertIn(dpid_a, self.napp.controller.switches)
+        self.assertNotIn(dpid_x, self.napp.controller.switches)
+        switch = self.napp.controller.switches[dpid_a]
+
+        self.assertEqual(switch.id, dpid_a)
+        self.assertEqual(switch.dpid, dpid_a)
+        self.assertTrue(switch.is_enabled())
+        self.assertFalse(switch.is_active())
+
+        self.assertEqual(len(switch.interfaces), 1)
+        self.assertIn(1, switch.interfaces)
+        self.assertNotIn(2, switch.interfaces)
+        interface = switch.interfaces[1]
+        self.assertEqual(interface.id, iface_a)
+        self.assertEqual(interface.switch.id, dpid_a)
+        self.assertEqual(interface.port_number, 1)
+        self.assertTrue(interface.is_enabled())
+        self.assertFalse(interface.is_active())
+        self.assertTrue(interface.lldp)
+        self.assertTrue(interface.uni)
+        self.assertFalse(interface.nni)
+
+    def test_load_switch_attrs(self):
+        """Test _load_switch."""
+        dpid_b = "00:00:00:00:00:00:00:02"
+        iface_b = f'{dpid_b}:1'
+        switch_attrs = {
+            "active": True,
+            "connection": "127.0.0.1:43230",
+            "data_path": "XX Human readable desc of dp",
+            "dpid": "00:00:00:00:00:00:00:02",
+            "enabled": False,
+            "hardware": "Open vSwitch",
+            "id": "00:00:00:00:00:00:00:02",
+            "interfaces": {
+                "00:00:00:00:00:00:00:02:1": {
+                    "active": True,
+                    "enabled": False,
+                    "id": "00:00:00:00:00:00:00:02:1",
+                    "link": "",
+                    "lldp": False,
+                    "mac": "de:58:c3:30:b7:b7",
+                    "metadata": {},
+                    "name": "s2-eth1",
+                    "nni": False,
+                    "port_number": 1,
+                    "speed": 1250000000,
+                    "switch": "00:00:00:00:00:00:00:02",
+                    "type": "interface",
+                    "uni": True
+                },
+            },
+            "manufacturer": "Nicira, Inc.",
+            "metadata": {},
+            "name": "00:00:00:00:00:00:00:04",
+            "ofp_version": "0x04",
+            "serial": "XX serial number",
+            "software": "2.10.7",
+            "type": "switch"
+        }
+
+        self.napp._load_switch(dpid_b, switch_attrs)
+
+        self.assertEqual(len(self.napp.controller.switches), 1)
+        self.assertIn(dpid_b, self.napp.controller.switches)
+
+        switch = self.napp.controller.switches[dpid_b]
+        self.assertEqual(switch.id, dpid_b)
+        self.assertEqual(switch.dpid, dpid_b)
+        self.assertFalse(switch.is_enabled())
+        self.assertFalse(switch.is_active())
+        self.assertEqual(switch.description['manufacturer'], 'Nicira, Inc.')
+        self.assertEqual(switch.description['hardware'], 'Open vSwitch')
+        self.assertEqual(switch.description['software'], '2.10.7')
+        self.assertEqual(switch.description['serial'], 'XX serial number')
+        self.assertEqual(switch.description['data_path'],
+                         'XX Human readable desc of dp')
+
+        self.assertEqual(len(switch.interfaces), 1)
+        self.assertIn(1, switch.interfaces)
+        self.assertNotIn(2, switch.interfaces)
+
+        interface = switch.interfaces[1]
+        self.assertEqual(interface.id, iface_b)
+        self.assertEqual(interface.switch.id, dpid_b)
+        self.assertEqual(interface.port_number, 1)
+        self.assertFalse(interface.is_enabled())
+        self.assertFalse(interface.is_active())
+        self.assertFalse(interface.lldp)
+        self.assertTrue(interface.uni)
+        self.assertFalse(interface.nni)
+
+    def test_load_link(self):
+        """Test _load_link."""
+        dpid_a = "00:00:00:00:00:00:00:01"
+        dpid_b = "00:00:00:00:00:00:00:02"
+        mock_switch_a = get_switch_mock(dpid_a, 0x04)
+        mock_switch_b = get_switch_mock(dpid_b, 0x04)
+        mock_interface_a = get_interface_mock('s1-eth1', 1, mock_switch_a)
+        mock_interface_a.id = dpid_a + ':1'
+        mock_interface_b = get_interface_mock('s2-eth1', 1, mock_switch_b)
+        mock_interface_b.id = dpid_b + ':1'
+        mock_switch_a.interfaces = {1: mock_interface_a}
+        mock_switch_b.interfaces = {1: mock_interface_b}
+        self.napp.controller.switches[dpid_a] = mock_switch_a
+        self.napp.controller.switches[dpid_b] = mock_switch_b
+        link_attrs = {
+            'enabled': True,
+            'endpoint_a': {
+                'switch': dpid_a,
+                'port_number': 1
+            },
+            'endpoint_b': {
+                'switch': dpid_b,
+                'port_number': 1
+            }
+        }
+
+        self.napp._load_link(link_attrs)
+
+        self.assertEqual(len(self.napp.links), 1)
+        link = list(self.napp.links.values())[0]
+
+        self.assertEqual(link.endpoint_a.id, mock_interface_a.id)
+        self.assertEqual(link.endpoint_b.id, mock_interface_b.id)
+        self.assertTrue(mock_interface_a.nni)
+        self.assertTrue(mock_interface_b.nni)
+        self.assertEqual(mock_interface_a.update_link.call_count, 1)
+        self.assertEqual(mock_interface_b.update_link.call_count, 1)
+
+        # test enable/disable
         link_id = '4d42dc08522'
-        mock_switch_a = get_switch_mock(dpid)
-        mock_switch_b = get_switch_mock(dpid_b)
-        mock_interface_a_1 = get_interface_mock('s1-eth1', 1, mock_switch_a)
-        mock_interface_b_1 = get_interface_mock('s2-eth1', 1, mock_switch_b)
-        mock_link = get_link_mock(mock_interface_a_1, mock_interface_b_1)
+        mock_interface_a = get_interface_mock('s1-eth1', 1, mock_switch_a)
+        mock_interface_b = get_interface_mock('s2-eth1', 1, mock_switch_b)
+        mock_link = get_link_mock(mock_interface_a, mock_interface_b)
         mock_link.id = link_id
-        self.napp.links = {link_id: mock_link}
-        self.napp.links_state = {link_id: {'enabled': True}}
-        # enable link
-        self.napp.restore_network_status(mock_link)
-        self.assertEqual(mock_link.enable.call_count, 1)
-
-        # disable link
-        self.napp.links_state = {link_id: {"enabled": False}}
-        self.napp._verified_links = []
-        self.napp.restore_network_status(mock_link)
-        self.assertEqual(mock_link.disable.call_count, 1)
+        with patch('napps.kytos.topology.main.Main._get_link_or_create',
+                   return_value=mock_link):
+            # enable link
+            link_attrs['enabled'] = True
+            self.napp.links = {link_id: mock_link}
+            self.napp._load_link(link_attrs)
+            self.assertEqual(mock_link.enable.call_count, 1)
+            # disable link
+            link_attrs['enabled'] = False
+            self.napp.links = {link_id: mock_link}
+            self.napp._load_link(link_attrs)
+            self.assertEqual(mock_link.disable.call_count, 1)
 
-    def test_fail_restore_link(self):
-        """Test fail restore_link."""
-        dpid = '00:00:00:00:00:00:00:01'
+    @patch('napps.kytos.topology.main.Main._get_link_or_create')
+    def test_fail_load_link(self, get_link_or_create_mock):
+        """Test fail load_link."""
+        dpid_a = '00:00:00:00:00:00:00:01'
         dpid_b = '00:00:00:00:00:00:00:02'
         link_id = '4d42dc08522'
-        link_id_fail = '4cd52'
-        mock_switch_a = get_switch_mock(dpid)
+        mock_switch_a = get_switch_mock(dpid_a)
         mock_switch_b = get_switch_mock(dpid_b)
         mock_interface_a_1 = get_interface_mock('s1-eth1', 1, mock_switch_a)
         mock_interface_b_1 = get_interface_mock('s2-eth1', 1, mock_switch_b)
         mock_link = get_link_mock(mock_interface_a_1, mock_interface_b_1)
         mock_link.id = link_id
         self.napp.links = {link_id: mock_link}
-        self.napp.links_state = {link_id: {"enabled": True}}
-        with self.assertRaises(RestoreError):
-            self.napp._restore_link(link_id_fail)
-
-        self.napp.links_state = {link_id_fail: {"enabled": True}}
-        with self.assertRaises(RestoreError):
-            self.napp._restore_link(link_id_fail)
-
-    def test_fail_restore_switch(self):
-        """Test fail restore_switch."""
-        dpid = '00:00:00:00:00:00:00:01'
-        dpid_fail = '00:00:00:00:00:00:00:06'
-        mock_switch = get_switch_mock(dpid)
-        mock_switch.id = dpid
-        mock_interface = get_interface_mock('s1-eth1', 1, mock_switch)
-        mock_switch.interfaces = {1: mock_interface}
-        self.napp.controller.switche = {dpid: mock_switch}
-        self.napp.switches_state = {dpid: True}
-        self.napp.interfaces_state = {'00:00:00:00:00:00:00:01:1': (True,
-                                                                    True)}
-
+        get_link_or_create_mock.return_value = mock_link
+
+        link_attrs_fail = {
+            'enabled': True,
+            'endpoint_a': {
+                'switch': dpid_a,
+                'port_number': 999
+            },
+            'endpoint_b': {
+                'switch': dpid_b,
+                'port_number': 999
+            }
+        }
         with self.assertRaises(RestoreError):
-            self.napp._restore_switch(dpid_fail)
-
-        self.napp.switches_state = {dpid_fail: True}
+            self.napp._load_link(link_attrs_fail)
+
+        link_attrs_fail = {
+            'enabled': True,
+            'endpoint_a': {
+                'switch': '00:00:00:00:00:00:00:99',
+                'port_number': 1
+            },
+            'endpoint_b': {
+                'switch': '00:00:00:00:00:00:00:77',
+                'port_number': 1
+            }
+        }
         with self.assertRaises(RestoreError):
-            self.napp._restore_switch(dpid_fail)
+            self.napp._load_link(link_attrs_fail)
 
     @patch('napps.kytos.topology.main.Main.save_status_on_storehouse')
     def test_enable_switch(self, mock_save_status):

From e44f3b4f85db8f22cec481179ef55c309ca67d9a Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Fri, 11 Jun 2021 22:00:39 -0400
Subject: [PATCH 19/28] saving the topology when elements are added and using
 Lock to avoid race conditions

---
 main.py                 | 38 ++++++++++++++++++++++++++++----------
 tests/unit/test_main.py | 23 +++++++++++++++++++----
 2 files changed, 47 insertions(+), 14 deletions(-)

diff --git a/main.py b/main.py
index 719ab8e..ce17bff 100644
--- a/main.py
+++ b/main.py
@@ -4,6 +4,7 @@
 """
 import time
 from datetime import datetime, timezone
+from threading import Lock
 
 from flask import jsonify, request
 from werkzeug.exceptions import BadRequest, UnsupportedMediaType
@@ -41,6 +42,8 @@ def setup(self):
 
         self.storehouse = StoreHouse(self.controller)
 
+        self._lock = Lock()
+
     def execute(self):
         """Execute once when the napp is running."""
         self._load_network_status()
@@ -145,6 +148,17 @@ def _load_switch(self, switch_id, switch_att):
             interface.lldp = iface_att['lldp']
             switch.update_interface(interface)
             self.update_instance_metadata(interface)
+            name = 'kytos/topology.port.created'
+            event = KytosEvent(name=name, content={
+                                              'switch': switch_id,
+                                              'port': interface.port_number,
+                                              'port_description': {
+                                                  'alias': interface.name,
+                                                  'mac': interface.address,
+                                                  'state': interface.state
+                                                  }
+                                              })
+            self.controller.buffers.app.put(event)
 
     def _load_link(self, link_att):
         dpid_a = link_att['endpoint_a']['switch']
@@ -500,6 +514,7 @@ def handle_new_switch(self, event):
         switch = event.content['switch']
         switch.activate()
         log.debug('Switch %s added to the Topology.', switch.id)
+        self.save_status_on_storehouse()
         self.notify_topology_update()
         self.update_instance_metadata(switch)
         if switch.is_enabled():
@@ -532,6 +547,7 @@ def handle_interface_up(self, event):
     def handle_interface_created(self, event):
         """Update the topology based on a Port Create event."""
         self.handle_interface_up(event)
+        self.save_status_on_storehouse()
 
     def handle_interface_down(self, event):
         """Update the topology based on a Port Modify event.
@@ -645,6 +661,7 @@ def add_links(self, event):
         interface_b.nni = True
 
         self.notify_topology_update()
+        self.save_status_on_storehouse()
 
     # def add_host(self, event):
     #    """Update the topology with a new Host."""
@@ -667,16 +684,17 @@ def add_links(self, event):
     @listen_to('.*.network_status.updated')
     def save_status_on_storehouse(self, event=None):
         """Save the network administrative status using storehouse."""
-        status = self._get_switches_dict()
-        status['id'] = 'network_status'
-        if event:
-            content = event.content
-            log.info(f"Storing the administrative state of the"
-                     f" {content['attribute']} attribute to"
-                     f" {content['state']} in the interfaces"
-                     f" {content['interface_ids']}")
-        status.update(self._get_links_dict())
-        self.storehouse.save_status(status)
+        with self._lock:
+            status = self._get_switches_dict()
+            status['id'] = 'network_status'
+            if event:
+                content = event.content
+                log.info(f"Storing the administrative state of the"
+                         f" {content['attribute']} attribute to"
+                         f" {content['state']} in the interfaces"
+                         f" {content['interface_ids']}")
+            status.update(self._get_links_dict())
+            self.storehouse.save_status(status)
 
     def notify_switch_enabled(self, dpid):
         """Send an event to notify that a switch is enabled."""
diff --git a/tests/unit/test_main.py b/tests/unit/test_main.py
index 36f64fd..5dbfd6a 100644
--- a/tests/unit/test_main.py
+++ b/tests/unit/test_main.py
@@ -320,8 +320,11 @@ def test_load_network_status_fail_link(self, *args):
         error = 'Error loading link: xpto'
         mock_log.error.assert_called_with(error)
 
-    def test_load_switch(self):
+    @patch('napps.kytos.topology.main.KytosEvent')
+    @patch('kytos.core.buffers.KytosEventBuffer.put')
+    def test_load_switch(self, *args):
         """Test _load_switch."""
+        (mock_buffers_put, mock_event) = args
         dpid_a = "00:00:00:00:00:00:00:01"
         dpid_x = "00:00:00:00:00:00:00:XX"
         iface_a = f'{dpid_a}:1'
@@ -355,6 +358,9 @@ def test_load_switch(self):
         self.assertEqual(len(switch.interfaces), 1)
         self.assertIn(1, switch.interfaces)
         self.assertNotIn(2, switch.interfaces)
+        mock_event.assert_called()
+        mock_buffers_put.assert_called()
+
         interface = switch.interfaces[1]
         self.assertEqual(interface.id, iface_a)
         self.assertEqual(interface.switch.id, dpid_a)
@@ -992,9 +998,12 @@ def test_delete_link_metadata(self, mock_metadata_changes):
 
     @patch('napps.kytos.topology.main.Main.notify_topology_update')
     @patch('napps.kytos.topology.main.Main.update_instance_metadata')
+    @patch('napps.kytos.topology.main.StoreHouse.save_status')
     def test_handle_new_switch(self, *args):
         """Test handle_new_switch."""
-        (mock_instance_metadata, mock_notify_topology_update) = args
+        (mock_instance_metadata, mock_notify_topology_update,
+         mock_save_status) = args
+        mock_save_status.return_value = True
         mock_event = MagicMock()
         mock_switch = create_autospec(Switch)
         mock_event.content['switch'] = mock_switch
@@ -1025,8 +1034,11 @@ def test_handle_interface_up(self, *args):
         mock_instance_metadata.assert_called()
 
     @patch('napps.kytos.topology.main.Main.handle_interface_up')
-    def test_handle_interface_created(self, mock_handle_interface_up):
+    @patch('napps.kytos.topology.main.StoreHouse.save_status')
+    def test_handle_interface_created(self, *args):
         """Test handle interface created."""
+        (mock_handle_interface_up, mock_save_status) = args
+        mock_save_status.return_value = True
         mock_event = MagicMock()
         self.napp.handle_interface_created(mock_event)
         mock_handle_interface_up.assert_called()
@@ -1099,9 +1111,12 @@ def test_interface_link_down(self, *args):
 
     @patch('napps.kytos.topology.main.Main._get_link_or_create')
     @patch('napps.kytos.topology.main.Main.notify_topology_update')
+    @patch('napps.kytos.topology.main.StoreHouse.save_status')
     def test_add_links(self, *args):
         """Test add_links."""
-        (mock_notify_topology_update, mock_get_link_or_create) = args
+        (mock_notify_topology_update, mock_get_link_or_create,
+         mock_save_status) = args
+        mock_save_status.return_value = True
         mock_event = MagicMock()
         self.napp.add_links(mock_event)
         mock_get_link_or_create.assert_called()

From 3dd855247cd48a2812659599ba814f5c9d36b8ef Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Tue, 6 Jul 2021 10:15:59 -0400
Subject: [PATCH 20/28] loading network status when storehouse is load (which
 can happens before the topology)

---
 main.py | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/main.py b/main.py
index ce17bff..646ad22 100644
--- a/main.py
+++ b/main.py
@@ -44,9 +44,11 @@ def setup(self):
 
         self._lock = Lock()
 
+    @listen_to('kytos/storehouse.loaded')
     def execute(self):
         """Execute once when the napp is running."""
-        self._load_network_status()
+        with self._lock:
+            self._load_network_status()
 
     def shutdown(self):
         """Do nothing."""

From b38231fc1cab27c25b196d7507ac95490926528b Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Tue, 6 Jul 2021 10:17:16 -0400
Subject: [PATCH 21/28] saving topology status only when a new link is
 discovered (instead of every event from of_lldp)

---
 main.py | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/main.py b/main.py
index 646ad22..f3fc635 100644
--- a/main.py
+++ b/main.py
@@ -651,11 +651,17 @@ def add_links(self, event):
         interface_b = event.content['interface_b']
 
         try:
-            link = self._get_link_or_create(interface_a, interface_b)
+            link = Link(interface_a, interface_b)
         except KytosLinkCreationError as err:
             log.error(f'Error creating link: {err}.')
             return
 
+        if link.id in self.links:
+            log.debug(f'Already existing link id={link.id}')
+            return
+
+        self.links[link.id] = link
+
         interface_a.update_link(link)
         interface_b.update_link(link)
 

From 18d35193ca0a6fa44a4ac1135a298ab9f5b6e3d4 Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Fri, 13 Aug 2021 10:46:06 -0300
Subject: [PATCH 22/28] removing storehouse save from auto-discovery functions
 (the admin status will save only when requested by the user)

---
 main.py | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/main.py b/main.py
index f3fc635..650b550 100644
--- a/main.py
+++ b/main.py
@@ -516,7 +516,6 @@ def handle_new_switch(self, event):
         switch = event.content['switch']
         switch.activate()
         log.debug('Switch %s added to the Topology.', switch.id)
-        self.save_status_on_storehouse()
         self.notify_topology_update()
         self.update_instance_metadata(switch)
         if switch.is_enabled():
@@ -549,7 +548,6 @@ def handle_interface_up(self, event):
     def handle_interface_created(self, event):
         """Update the topology based on a Port Create event."""
         self.handle_interface_up(event)
-        self.save_status_on_storehouse()
 
     def handle_interface_down(self, event):
         """Update the topology based on a Port Modify event.
@@ -669,7 +667,6 @@ def add_links(self, event):
         interface_b.nni = True
 
         self.notify_topology_update()
-        self.save_status_on_storehouse()
 
     # def add_host(self, event):
     #    """Update the topology with a new Host."""

From ccafb37d4ae6969244e5a2260fb22a7171942bcc Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Fri, 13 Aug 2021 10:48:16 -0300
Subject: [PATCH 23/28] change tests back to not consider storehouse save
 status when handling automatic events

---
 tests/unit/test_main.py | 15 +++------------
 1 file changed, 3 insertions(+), 12 deletions(-)

diff --git a/tests/unit/test_main.py b/tests/unit/test_main.py
index 5dbfd6a..b7b20b9 100644
--- a/tests/unit/test_main.py
+++ b/tests/unit/test_main.py
@@ -998,12 +998,9 @@ def test_delete_link_metadata(self, mock_metadata_changes):
 
     @patch('napps.kytos.topology.main.Main.notify_topology_update')
     @patch('napps.kytos.topology.main.Main.update_instance_metadata')
-    @patch('napps.kytos.topology.main.StoreHouse.save_status')
     def test_handle_new_switch(self, *args):
         """Test handle_new_switch."""
-        (mock_instance_metadata, mock_notify_topology_update,
-         mock_save_status) = args
-        mock_save_status.return_value = True
+        (mock_instance_metadata, mock_notify_topology_update) = args
         mock_event = MagicMock()
         mock_switch = create_autospec(Switch)
         mock_event.content['switch'] = mock_switch
@@ -1034,11 +1031,8 @@ def test_handle_interface_up(self, *args):
         mock_instance_metadata.assert_called()
 
     @patch('napps.kytos.topology.main.Main.handle_interface_up')
-    @patch('napps.kytos.topology.main.StoreHouse.save_status')
-    def test_handle_interface_created(self, *args):
+    def test_handle_interface_created(self, mock_handle_interface_up):
         """Test handle interface created."""
-        (mock_handle_interface_up, mock_save_status) = args
-        mock_save_status.return_value = True
         mock_event = MagicMock()
         self.napp.handle_interface_created(mock_event)
         mock_handle_interface_up.assert_called()
@@ -1111,12 +1105,9 @@ def test_interface_link_down(self, *args):
 
     @patch('napps.kytos.topology.main.Main._get_link_or_create')
     @patch('napps.kytos.topology.main.Main.notify_topology_update')
-    @patch('napps.kytos.topology.main.StoreHouse.save_status')
     def test_add_links(self, *args):
         """Test add_links."""
-        (mock_notify_topology_update, mock_get_link_or_create,
-         mock_save_status) = args
-        mock_save_status.return_value = True
+        (mock_notify_topology_update, mock_get_link_or_create) = args
         mock_event = MagicMock()
         self.napp.add_links(mock_event)
         mock_get_link_or_create.assert_called()

From 1496e32354f0edc1229026158f4c5cc9ddf2f330 Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Fri, 13 Aug 2021 10:48:59 -0300
Subject: [PATCH 24/28] using controller.get_switch_or_create and
 switch.update_or_create_interface to create switches/interfaces

---
 main.py | 40 +++++++++++++++++-----------------------
 1 file changed, 17 insertions(+), 23 deletions(-)

diff --git a/main.py b/main.py
index 650b550..d687492 100644
--- a/main.py
+++ b/main.py
@@ -121,10 +121,7 @@ def _get_link_from_interface(self, interface):
 
     def _load_switch(self, switch_id, switch_att):
         log.info(f'Loading switch from storehouse dpid={switch_id}')
-        switch = Switch(dpid=switch_id)
-        self.controller.add_new_switch(switch)
-        # workaround so switch.is_active() returns False
-        switch.lastseen = datetime(1, 1, 1, 0, 0, 0, 0, timezone.utc)
+        switch = self.controller.get_switch_or_create(switch_id)
         if switch_att['enabled']:
             switch.enable()
         else:
@@ -135,20 +132,19 @@ def _load_switch(self, switch_id, switch_att):
         switch.description['serial'] = switch_att.get('serial', '')
         switch.description['data_path'] = switch_att.get('data_path', '')
         self.update_instance_metadata(switch)
+
         for iface_id, iface_att in switch_att.get('interfaces', {}).items():
             log.info(f'Loading interface iface_id={iface_id}')
-            interface = Interface(name=iface_att['name'],
-                                  port_number=iface_att['port_number'],
-                                  address=iface_att.get('mac', None),
-                                  speed=iface_att.get('speed', None),
-                                  switch=switch)
-            interface.deactivate()
+            interface = switch.update_or_create_interface(
+                            port_no=iface_att['port_number'],
+                            name=iface_att['name'],
+                            address=iface_att.get('mac', None),
+                            speed=iface_att.get('speed', None))
             if iface_att['enabled']:
                 interface.enable()
             else:
                 interface.disable()
             interface.lldp = iface_att['lldp']
-            switch.update_interface(interface)
             self.update_instance_metadata(interface)
             name = 'kytos/topology.port.created'
             event = KytosEvent(name=name, content={
@@ -210,21 +206,19 @@ def _load_network_status(self):
 
         log.debug("_load_network_status switches=%s" % switches)
         for switch_id, switch_att in switches.items():
-            if switch_id not in self.controller.switches:
-                try:
-                    self._load_switch(switch_id, switch_att)
-                # pylint: disable=broad-except
-                except Exception as err:
-                    log.error(f'Error loading switch: {err}')
+            try:
+                self._load_switch(switch_id, switch_att)
+            # pylint: disable=broad-except
+            except Exception as err:
+                log.error(f'Error loading switch: {err}')
 
         log.debug("_load_network_status links=%s" % links)
         for link_id, link_att in links.items():
-            if link_id not in self.links:
-                try:
-                    self._load_link(link_att)
-                # pylint: disable=broad-except
-                except Exception as err:
-                    log.error(f'Error loading link: {err}')
+            try:
+                self._load_link(link_att)
+            # pylint: disable=broad-except
+            except Exception as err:
+                log.error(f'Error loading link: {err}')
 
     @rest('v3/')
     def get_topology(self):

From fb81410a5562fa9de7ac7f19a61fa28e35a993ea Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Fri, 13 Aug 2021 10:54:47 -0300
Subject: [PATCH 25/28] rollback add_links change to use
 self._get_link_or_create()

---
 main.py | 8 +-------
 1 file changed, 1 insertion(+), 7 deletions(-)

diff --git a/main.py b/main.py
index d687492..d8f645a 100644
--- a/main.py
+++ b/main.py
@@ -643,17 +643,11 @@ def add_links(self, event):
         interface_b = event.content['interface_b']
 
         try:
-            link = Link(interface_a, interface_b)
+            link = self._get_link_or_create(interface_a, interface_b)
         except KytosLinkCreationError as err:
             log.error(f'Error creating link: {err}.')
             return
 
-        if link.id in self.links:
-            log.debug(f'Already existing link id={link.id}')
-            return
-
-        self.links[link.id] = link
-
         interface_a.update_link(link)
         interface_b.update_link(link)
 

From a667ef9775ade9ad6d50e83f07edb0e7e436b47c Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Fri, 13 Aug 2021 10:55:25 -0300
Subject: [PATCH 26/28] adding napp storehouse.loaded in the list of events

---
 tests/unit/test_main.py | 1 +
 1 file changed, 1 insertion(+)

diff --git a/tests/unit/test_main.py b/tests/unit/test_main.py
index b7b20b9..92639a7 100644
--- a/tests/unit/test_main.py
+++ b/tests/unit/test_main.py
@@ -41,6 +41,7 @@ def test_get_event_listeners(self):
                            'kytos/maintenance.end_link',
                            'kytos/maintenance.start_switch',
                            'kytos/maintenance.end_switch',
+                           'kytos/storehouse.loaded',
                            '.*.network_status.updated',
                            '.*.interface.is.nni',
                            '.*.connection.lost',

From f5e2a3013620f3e3e9d4efd25e65f67def78eea1 Mon Sep 17 00:00:00 2001
From: Italo Valcy <italo@ampath.net>
Date: Fri, 13 Aug 2021 11:07:15 -0300
Subject: [PATCH 27/28] fix pylint errors

---
 main.py | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/main.py b/main.py
index d8f645a..1a85ce1 100644
--- a/main.py
+++ b/main.py
@@ -3,7 +3,6 @@
 Manage the network topology
 """
 import time
-from datetime import datetime, timezone
 from threading import Lock
 
 from flask import jsonify, request
@@ -218,7 +217,7 @@ def _load_network_status(self):
                 self._load_link(link_att)
             # pylint: disable=broad-except
             except Exception as err:
-                log.error(f'Error loading link: {err}')
+                log.error(f'Error loading link {link_id}: {err}')
 
     @rest('v3/')
     def get_topology(self):

From 4a235669a165a39094d6492b3f2b39e1a698f3ba Mon Sep 17 00:00:00 2001
From: Italo Valcy <italovalcy@gmail.com>
Date: Tue, 24 Aug 2021 20:53:44 +0000
Subject: [PATCH 28/28] fix tests

---
 tests/unit/test_main.py | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/tests/unit/test_main.py b/tests/unit/test_main.py
index 92639a7..1e372ed 100644
--- a/tests/unit/test_main.py
+++ b/tests/unit/test_main.py
@@ -318,7 +318,7 @@ def test_load_network_status_fail_link(self, *args):
         mock_get_data.return_value = status
         mock_load_link.side_effect = Exception('xpto')
         self.napp._load_network_status()
-        error = 'Error loading link: xpto'
+        error = 'Error loading link 1: xpto'
         mock_log.error.assert_called_with(error)
 
     @patch('napps.kytos.topology.main.KytosEvent')
@@ -367,7 +367,6 @@ def test_load_switch(self, *args):
         self.assertEqual(interface.switch.id, dpid_a)
         self.assertEqual(interface.port_number, 1)
         self.assertTrue(interface.is_enabled())
-        self.assertFalse(interface.is_active())
         self.assertTrue(interface.lldp)
         self.assertTrue(interface.uni)
         self.assertFalse(interface.nni)
@@ -437,7 +436,6 @@ def test_load_switch_attrs(self):
         self.assertEqual(interface.switch.id, dpid_b)
         self.assertEqual(interface.port_number, 1)
         self.assertFalse(interface.is_enabled())
-        self.assertFalse(interface.is_active())
         self.assertFalse(interface.lldp)
         self.assertTrue(interface.uni)
         self.assertFalse(interface.nni)
